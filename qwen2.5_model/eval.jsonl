{"instruction": "Write a labels rule: Required labels\n\nCheck the image for the presence of labels that are required.\nUse the rule data `required_labels` key to set the list of labels\nto check, or the `fbc_required_labels` key for fbc images.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tis_set(_image_labels)\n\n\tsome err in _required_labels_errors\n\tresult := object.union(lib.result_helper(rego.metadata.chain(), []), err)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_packages rule: RPM Packages\n\nRules used to verify different properties of specific RPM packages found in the SBOM of the\nimage being validated.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_packages\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\timage.is_image_index(input.image.ref)\n\n\tsome rpm_name in rpm_names_with_mismatched_nvr_sets\n\tnot rpm_name in lib.rule_data(\"non_unique_rpm_names\")\n\n\tdetail_text := concat(\" \", sort(rpm_mismatch_details(rpm_name)))\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[rpm_name, detail_text],\n\t\trpm_name,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a source_image rule: Source image\n\nThis package is reponsible for verifying the source container image associated with the image\nbeing validated.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package source_image\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in _source_image_errors\n\tresult := lib.result_helper(rego.metadata.chain(), [error])\n}", "task_type": "implement"}
{"instruction": "Write a external_parameters rule: PipelineRun params provided\n\nConfirm the `pipeline_run_params` rule data was provided.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package external_parameters\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_cyclonedx rule: Disallowed package external references\n\nConfirm the CycloneDX SBOM contains only packages without disallowed\nexternal references. By default all external references are allowed. Use the\n\"disallowed_external_references\" rule data key to provide a list of type-pattern pairs\nthat forbid the use of an external reference of the given type where the reference url\nmatches the given pattern.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsome reference in component.externalReferences\n\tsome disallowed in lib.rule_data(sbom.rule_data_disallowed_external_references_key)\n\n\treference.type == disallowed.type\n\tregex.match(object.get(disallowed, \"url\", \"\"), object.get(reference, \"url\", \"\"))\n\n\tmsg := regex.replace(object.get(disallowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\tid := object.get(component, \"purl\", component.name)\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [id, reference.url, reference.type, msg], id)\n}", "task_type": "implement"}
{"instruction": "Write a test rule: No informative tests failed\n\nProduce a warning if any informative tests have their result set to \"FAILED\".\nThe result type is configurable by the \"failed_tests_results\" key, and the list\nof informative tests is configurable by the \"informative_tests\" key in the rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\ttest in lib.rule_data(\"informative_tests\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "implement"}
{"instruction": "Write a slsa_build_build_service rule: Allowed builder IDs provided\n\nConfirm the `allowed_builder_ids` rule data was provided, since it is required by the policy\nrules in this package.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_build_build_service\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Disallowed package external references\n\nConfirm the SPDX SBOM contains only packages without disallowed\nexternal references. By default all external references are allowed. Use the\n\"disallowed_external_references\" rule data key to provide a list of type-pattern pairs\nthat forbid the use of an external reference of the given type where the reference url\nmatches the given pattern.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\tsome reference in pkg.externalRefs\n\tsome disallowed in lib.rule_data(sbom.rule_data_disallowed_external_references_key)\n\n\treference.referenceType == disallowed.type\n\tregex.match(object.get(disallowed, \"url\", \"\"), object.get(reference, \"referenceLocator\", \"\"))\n\n\tmsg := regex.replace(object.get(disallowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\t# regal ignore:line-length\n\tresult := lib.result_helper(rego.metadata.chain(), [pkg.name, reference.referenceLocator, reference.referenceType, msg])\n}", "task_type": "implement"}
{"instruction": "Write a rpm_signature rule: Result format\n\nConfirm the format of the RPMS_DATA result is in the expected format.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_signature\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in _result_format_errors\n\tresult := lib.result_helper(rego.metadata.chain(), [error])\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Contains files\n\nCheck the list of files in the SPDX SBOM is not empty.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tcount(s.files) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_build_build_service rule: SLSA Builder ID found\n\nVerify that the attestation attribute predicate.builder.id is set.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_build_build_service\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tnot _builder_id(att)\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Task references are pinned\n\nCheck if all Tekton Tasks use a Task definition by a pinned reference. When using the git\nresolver, a commit ID is expected for the revision parameter. When using the bundles resolver,\nthe bundle parameter is expected to include an image reference with a digest.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome task in tekton.unpinned_task_references(lib.tasks_from_pipelinerun)\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), _task_info(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a github_certificate rule: GitHub Certificate Checks\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult := lib.result_helper(rego.metadata.chain(), [extension.name])\n}", "task_type": "implement"}
{"instruction": "Write a rhtap_multi_ci rule: RHTAP Multi-CI\n\nChecks for images built using an RHTAP build pipeline in either Jenkins,\nGitLab or GitHub. RHTAP pipelines are defined under\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rhtap_multi_ci\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(_attestations) < 1\n\tresult := lib.result_helper(rego.metadata.chain(), [lib.quoted_values_string(_known_build_types)])\n}", "task_type": "implement"}
{"instruction": "Write a rpm_signature rule: Rule data provided\n\nConfirm the expected `allowed_rpm_signature_keys` rule data key has been provided in the\nexpected format.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_signature\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Pinned Task references\n\nEnsure that all Tasks in the SLSA Provenance attestation use an immuntable reference to the\nTask definition.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\tnot tekton.task_ref(task).pinned\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.task_name(task), tekton.pipeline_task_name(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_pipeline rule: RPM Pipeline\n\nThis package provides rules for verifying the RPMs are built in an approved pipeline\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_pipeline\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\n\tlabels := tekton.task_labels(task)\n\tpipeline := labels[_pipeline_key]\n\tallowed_pipelines := lib.rule_data(_rule_data_key)\n\n\tnot pipeline in allowed_pipelines\n\n\tresult := lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), pipeline, concat(\",\", allowed_pipelines)],\n\t)\n}", "task_type": "implement"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nFeature annotations have expected value\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\tsome annotation in lib.rule_data(\"required_olm_features_annotations\")\n\tvalue := object.get(manifest.metadata.annotations, annotation, \"\")\n\tnot value in {\"true\", \"false\"}\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [annotation], annotation)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\tsome annotation in lib.rule_data(\"required_olm_features_annotations\")\n\tvalue:=object.get(manifest.metadata.annotations, annotation, \"\")\n\tnot value in {\"true\", \"false\"}\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [annotation], annotation)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRelated images references are from allowed registries\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\t# The presence of expected rule_data verified in _rule_data_errors\n\tallowed_olm_image_registry_prefixes := lib.rule_data(\"allowed_olm_image_registry_prefixes\")\n\n\t# Parse manifests from snapshot\n\tsome related_images in _related_images(input.image)\n\n\tsome img in related_images\n\tnot _image_registry_allowed(img.repo, allowed_olm_image_registry_prefixes)\n\n\timg_str := image.str(img)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [img_str], img.repo)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# The presence of expected rule_data verified in _rule_data_errors\n\tallowed_olm_image_registry_prefixes:=lib.rule_data(\"allowed_olm_image_registry_prefixes\")\n\n\t# Parse manifests from snapshot\n\tsome related_images in _related_images(input.image)\n\n\tsome img in related_images\n\tnot _image_registry_allowed(img.repo, allowed_olm_image_registry_prefixes)\n\n\timg_str:=image.str(img)\n\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [img_str], img.repo)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTask called with hermetic param set\n\nFix spacing, formatting, and style issues.", "context": "package hermetic_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome not_hermetic_task in _not_hermetic_tasks\n\tresult := lib.result_helper(rego.metadata.chain(), [tekton.task_name(not_hermetic_task)])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome not_hermetic_task in _not_hermetic_tasks\n\tresult:=lib.result_helper(rego.metadata.chain(), [tekton.task_name(not_hermetic_task)])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSLSA Provenance Attestation Found\n\nFix spacing, formatting, and style issues.", "context": "package rhtap_multi_ci\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(_attestations) < 1\n\tresult := lib.result_helper(rego.metadata.chain(), [lib.quoted_values_string(_known_build_types)])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tcount(_attestations) < 1\n\tresult:=lib.result_helper(rego.metadata.chain(), [lib.quoted_values_string(_known_build_types)])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSuccessful pipeline tasks\n\nFix spacing, formatting, and style issues.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\tsome status in _status(task)\n\tstatus != \"Succeeded\"\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), status], tekton.pipeline_task_name(task),\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\tsome status in _status(task)\n\tstatus != \"Succeeded\"\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), status], tekton.pipeline_task_name(task),\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nPipelineRun attestation found\n\nFix spacing, formatting, and style issues.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(lib.pipelinerun_attestations) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tcount(lib.pipelinerun_attestations)==0\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nBlocking CVE check\n\nFix spacing, formatting, and style issues.", "context": "package cve\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome level, vulns in _grouped_vulns.restrict_cve_security_levels\n\tsome vuln in vulns\n\n\tleeway := _compute_leeway(vuln, level)\n\tname := _name(vuln)\n\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, level], name),\n\t\tleeway,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome level, vulns in _grouped_vulns.restrict_cve_security_levels\n\tsome vuln in vulns\n\n\tleeway:=_compute_leeway(vuln, level)\n\tname:=_name(vuln)\n\n\tresult:=_with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, level], name),\n\t\tleeway,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nNon-blocking unpatched CVE check\n\nFix spacing, formatting, and style issues.", "context": "package cve\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome level, vulns in _grouped_vulns.warn_unpatched_cve_security_levels\n\tsome vuln in vulns\n\n\tname := _name(vuln)\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [name, level], name)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome level, vulns in _grouped_vulns.warn_unpatched_cve_security_levels\n\tsome vuln in vulns\n\n\tname:=_name(vuln)\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [name, level], name)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTask tracking data was provided\n\nFix spacing, formatting, and style issues.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\ttekton.missing_trusted_tasks_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\ttekton.missing_trusted_tasks_data\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nDeprecated policy attestation format\n\nFix spacing, formatting, and style issues.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# Use input.attestations directly so we can detect the actual format in use.\n\tsome att in input.attestations\n\tnot att.statement\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# Use input.attestations directly so we can detect the actual format in use.\n\tsome att in input.attestations\n\tnot att.statement\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nAllowed package external references\n\nFix spacing, formatting, and style issues.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\tsome reference in pkg.externalRefs\n\tsome allowed in lib.rule_data(sbom.rule_data_allowed_external_references_key)\n\treference.referenceType == allowed.type\n\tnot regex.match(object.get(allowed, \"url\", \"\"), object.get(reference, \"referenceLocator\", \"\"))\n\n\tmsg := regex.replace(object.get(allowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\t# regal ignore:line-length\n\tresult := lib.result_helper(rego.metadata.chain(), [pkg.name, reference.referenceLocator, reference.referenceType, msg])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\tsome reference in pkg.externalRefs\n\tsome allowed in lib.rule_data(sbom.rule_data_allowed_external_references_key)\n\treference.referenceType==allowed.type\n\tnot regex.match(object.get(allowed, \"url\", \"\"), object.get(reference, \"referenceLocator\", \"\"))\n\n\tmsg:=regex.replace(object.get(allowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\t# regal ignore:line-length\n\tresult:=lib.result_helper(rego.metadata.chain(), [pkg.name, reference.referenceLocator, reference.referenceType, msg])\n}"}
