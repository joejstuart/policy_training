{"instruction": "Write a schedule rule: Weekday Restriction\n\nCheck if the current weekday is allowed based on the rule data value from the key\n`disallowed_weekdays`. By default, the list is empty in which case *any* weekday is\nallowed. This check is enforced only for a \"release\" or \"production\"\npipeline, as determined by the value of the `pipeline_intention` rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday := lower(time.weekday(lib.time.effective_current_time_ns))\n\tdisallowed := {lower(w) | some w in lib.rule_data(\"disallowed_weekdays\")}\n\tcount(disallowed) > 0\n\ttoday in disallowed\n\tresult := lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}", "task_type": "implement"}
{"instruction": "Write a rpm_signature rule: RPM Signature\n\nThis package provides rules for verifying the signatures of RPMs identified in the the SLSA\nProvenance attestation.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_signature\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome key in _signature_keys\n\tnot key in _allowed_rpm_signature_keys\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [key, _allowed_rpm_signature_keys], key)\n}", "task_type": "implement"}
{"instruction": "Write a pre_build_script_task rule: Script runner image is a valid image reference\n\nVerify that a valid image reference is specified as image being\nused to run the pre-build script task\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\tref := tekton.task_result(task, _pre_build_run_script_runner_image_result)\n\tnot image.parse(ref)\n\tresult := lib.result_helper(rego.metadata.chain(), [ref])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: Test\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\ttest in lib.rule_data(\"informative_tests\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "implement"}
{"instruction": "Write a base_image_registries rule: Base images provided\n\nVerify the expected information was provided about which base images were used during\nthe build process. The list of base images comes from any associated CycloneDX or SPDX\nSBOMs.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package base_image_registries\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# Some images are built \"from scratch\" and not have any base images, e.g. UBI.\n\t# This check distinguishes such images by simply ensuring that at least one SBOM\n\t# is attached to the image.\n\tcount(sbom.all_sboms) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: Image digest is present in IMAGES_PROCESSED result\n\nEnsure that task producing the IMAGES_PROCESSED result contains the\ndigests of the built image.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\timg := image.parse(input.image.ref)\n\timg_digest := img.digest\n\n\tsome task in _grouped_processed_results_from_tests\n\n\tnot img_digest in object.get(task.value, [\"image\", \"digests\"], [])\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[task.name, img_digest],\n\t\ttask.name,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: All required tasks were included in the pipeline\n\nEnsure that the set of required tasks are included\nin the PipelineRun attestation.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome required_task in _missing_tasks(current_required_tasks.tasks)\n\n\t# Don't report an error if a task is required now, but not in the future\n\trequired_task in latest_required_tasks.tasks\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [_format_missing(required_task, false)], required_task)\n}", "task_type": "implement"}
{"instruction": "Write a slsa_build_build_service rule: SLSA Builder ID is known and accepted\n\nVerify that the attestation attribute predicate.builder.id is set to one\nof the values in the `allowed_builder_ids` rule data, e.g.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_build_build_service\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tallowed_builder_ids := lib.rule_data(_rule_data_key)\n\tsome att in lib.pipelinerun_attestations\n\tbuilder_id := _builder_id(att)\n\tnot builder_id in allowed_builder_ids\n\tresult := lib.result_helper(rego.metadata.chain(), [builder_id])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: No tests were skipped\n\nProduce a violation if any tests have their result set to \"SKIPPED\".\nA skipped result means a pre-requirement for executing the test was not met, e.g. a\nlicense key for executing a scanner was not provided.\nThe result type is configurable by the \"skipped_tests_results\" key in the rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"skipped_tests_results\"), \"n/a\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "implement"}
{"instruction": "Write a cve rule: Blocking CVE check\n\nThe SLSA Provenance attestation for the image is inspected to ensure CVEs that have a known fix\nand meet a certain security level have not been detected. If detected, this policy rule will\nfail. By default, only CVEs of critical and high security level cause a failure. This is\nconfigurable by the rule data key `restrict_cve_security_levels`. The available levels are\ncritical, high, medium, low, and unknown. In addition to that leeway can be granted per severity\nusing the `cve_leeway` rule data key containing days of allowed leeway, measured as time between\nfound vulnerability's public disclosure date and current effective time, per severity level.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package cve\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome level, vulns in _grouped_vulns.restrict_cve_security_levels\n\tsome vuln in vulns\n\n\tleeway := _compute_leeway(vuln, level)\n\tname := _name(vuln)\n\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, level], name),\n\t\tleeway,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a slsa_provenance_available rule: Allowed predicate types provided\n\nConfirm the `allowed_predicate_types` rule data was provided, since it is required by the policy\nrules in this package.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_provenance_available\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a hermetic_task rule: Task called with hermetic param set\n\nVerify the task in the PipelineRun attestation was invoked with the\nproper parameters to make the task execution hermetic.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package hermetic_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome not_hermetic_task in _not_hermetic_tasks\n\tresult := lib.result_helper(rego.metadata.chain(), [tekton.task_name(not_hermetic_task)])\n}", "task_type": "implement"}
{"instruction": "Write a rpm_ostree_task rule: Rule data\n\nVerify the rule data used by this package, `allowed_rpm_ostree_builder_image_prefixes`, is in\nthe expected format.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_ostree_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a test rule: No tests failed\n\nProduce a violation if any non-informative tests have their result set to \"FAILED\".\nThe result type is configurable by the \"failed_tests_results\" key, and the list\nof informative tests is configurable by the \"informative_tests\" key in the rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\tnot test in lib.rule_data(\"informative_tests\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Rule data provided\n\nConfirm the expected rule data keys have been provided in the expected format. The keys are\n`required_labels`,\t`fbc_required_labels`, `optional_labels`, `fbc_optional_labels`,\n`disallowed_inherited_labels`, `fbc_disallowed_inherited_labels`, and `deprecated_labels`.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Required tasks list was provided\n\nConfirm the `required-tasks` rule data was provided, since it's\nrequired by the policy rules in this package.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\ttekton.missing_required_tasks_data\n\tnot required_pipeline_task_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Future required tasks were found\n\nProduce a warning when a task that will be required in the future\nwas not included in the PipelineRun attestation.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome required_task in _missing_tasks(latest_required_tasks.tasks)\n\n\t# If the required_task is also part of the current_required_tasks, do\n\t# not proceed with a warning since that's clearly a violation.\n\tnot required_task in current_required_tasks.tasks\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[_format_missing(required_task, true), latest_required_tasks.effective_on],\n\t\trequired_task,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a external_parameters rule: Restrict shared volumes\n\nVerify the PipelineRun did not use any pre-existing PersistentVolumeClaim\nworkspaces.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package external_parameters\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome provenance in lib.pipelinerun_attestations\n\tshared_workspaces := {w |\n\t\tsome w in provenance.statement.predicate.buildDefinition.externalParameters.runSpec.workspaces\n\t\tw.persistentVolumeClaim\n\t}\n\tcount(shared_workspaces) > 0\n\tresult := lib.result_helper(rego.metadata.chain(), [shared_workspaces])\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Inaccessible parent image manifest\n\nThe parent image manifest is not accessible.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t_has_parent\n\tis_null(_parent.manifest)\n\tresult := lib.result_helper(rego.metadata.chain(), [_parent.ref, input.image.ref])\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Labels\n\nCheck if the image has the expected labels set. The rules in this package\ndistinguish file-based catalog (FBC) images from all other images. When\nchecking an FBC image, a policy rule may use a different set of rule data.\nAn FBC image is detected by the presence of the\noperators.operatorframework.io.index.configs.v1 label.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tfound_labels := {label.name | some label in _image_labels}\n\tsome optional_label in optional_labels\n\tname := optional_label.name\n\tnot name in found_labels\n\tdescription := optional_label.description\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, description], name),\n\t\toptional_label,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a attestation_type rule: Attestation type\n\nSanity checks related to the format of the image build's attestation.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\n\t# regal ignore:leaked-internal-reference\n\tatt_type := att.statement._type\n\tnot att_type in lib.rule_data(_rule_data_key)\n\tresult := lib.result_helper(rego.metadata.chain(), [att_type])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_source_correlated rule: Source reference\n\nAttestation contains source reference.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(_source_references) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: No tests erred\n\nProduce a violation if any tests have their result set to \"ERROR\".\nThe result type is configurable by the \"erred_tests_results\" key in the rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"erred_tests_results\"), \"n/a\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_packages rule: Unique Version\n\nCheck if a multi-arch build has the same RPM versions installed across each different\narchitecture. This check only applies for Image Indexes, aka multi-platform images.\nUse the `non_unique_rpm_names` rule data key to ignore certain RPMs.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_packages\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\timage.is_image_index(input.image.ref)\n\n\tsome rpm_name in rpm_names_with_mismatched_nvr_sets\n\tnot rpm_name in lib.rule_data(\"non_unique_rpm_names\")\n\n\tdetail_text := concat(\" \", sort(rpm_mismatch_details(rpm_name)))\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[rpm_name, detail_text],\n\t\trpm_name,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_cyclonedx rule: Disallowed package attributes\n\nConfirm the CycloneDX SBOM contains only packages without disallowed\nattributes. By default all attributes are allowed. Use the\n\"disallowed_attributes\" rule data key to provide a list of key-value pairs\nthat forbid the use of an attribute set to the given value.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsome property in component.properties\n\tsome disallowed in lib.rule_data(sbom.rule_data_attributes_key)\n\n\tproperty.name == disallowed.name\n\tobject.get(property, \"value\", \"\") == object.get(disallowed, \"value\", \"\")\n\n\tmsg := regex.replace(object.get(property, \"value\", \"\"), `(.+)`, ` to \"$1\"`)\n\n\tid := object.get(component, \"purl\", component.name)\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [id, property.name, msg], id),\n\t\tdisallowed,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a pre_build_script_task rule: Pre-build-script task checks\n\nThis package verifies that the pre-build-script tasks in the\nattestation are executed in a controlled environment\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\timage_ref := tekton.task_param(task, _pre_build_script_runner_image_param)\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "implement"}
{"instruction": "Write a provenance_materials rule: Provenance Materials\n\nThis package provides rules for verifying the contents of the materials section\nof the SLSA Provenance attestation.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package provenance_materials\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tcount(tekton.git_clone_tasks(attestation)) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Allowed package sources\n\nFor each of the packages fetched by Hermeto which define externalReferences,\nverify they are allowed based on the allowed_package_sources rule data\nkey. By default, allowed_package_sources is empty, which means no components with such\nreferences are allowed.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\n\t# only look at components fetched by Hermeto\n\t# cachi2 is kept here for backwards compatibility\n\tsome annotation in pkg.annotations\n\tproperties := json.unmarshal(annotation.comment)\n\tproperties.name in {\"hermeto:found_by\", \"cachi2:found_by\"}\n\tproperties.value in {\"hermeto\", \"cachi2\"}\n\n\tsome externalref in pkg.externalRefs\n\n\texternalref.referenceType == \"purl\"\n\n\tpurl := externalref.referenceLocator\n\tparsed_purl := ec.purl.parse(purl)\n\n\t# patterns are either those defined by the rule for a given purl type, or empty by default\n\tallowed_data := lib.rule_data(sbom.rule_data_allowed_package_sources_key)\n\tpatterns := sbom.purl_allowed_patterns(parsed_purl.type, allowed_data)\n\n\tsome qualifier in parsed_purl.qualifiers\n\tqualifier.key == \"download_url\"\n\n\tnot sbom.url_matches_any_pattern(qualifier.value, patterns)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [purl, qualifier.value], purl)\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Tasks\n\nConforma expects that a set of tasks were\nincluded in the pipeline build for each image to be\nreleased. This package includes a set of rules to verify\nthat the expected tasks ran in the pipeline when the image\nwas built.\nRequired tasks for a pipeline are specified in a data source\nprovided at runtime. This data source features two primary\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a source_image rule: Exists\n\nVerify the source container image exists.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package source_image\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in _source_image_errors\n\tresult := lib.result_helper(rego.metadata.chain(), [error])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: Test\n\nConforma requires that each build was subjected\nto a set of tests and that those tests all passed. This package\nincludes a set of rules to verify that.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\ttest in lib.rule_data(\"informative_tests\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_repos rule: RPM Repos\n\nThis package defines rules to confirm that all RPM packages listed\nin SBOMs specify a known and permitted repository id.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_repos\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [_rule_data_key, e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a test rule: Rule data provided\n\nConfirm the expected rule data keys have been provided in the expected format. The keys are\n`supported_tests_results`, `failed_tests_results`, `informative_tests`, `erred_tests_results`,\n`skipped_tests_results`, and `warned_tests_results`.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a provenance_materials rule: Git clone source matches materials provenance\n\nConfirm that the result of the git-clone task is included in the materials section of the SLSA\nprovenance attestation.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package provenance_materials\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\n\tsome task in tekton.git_clone_tasks(attestation)\n\turl := _normalize_git_url(tekton.task_result(task, \"url\"))\n\tcommit := tekton.task_result(task, \"commit\")\n\n\tmaterials := [m |\n\t\tsome m in attestation.statement.predicate.materials\n\t\tm.uri == url\n\t\tm.digest.sha1 == commit\n\t]\n\tcount(materials) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [url, commit])\n}", "task_type": "implement"}
{"instruction": "Write a buildah_build_task rule: Buildah build task\n\nThis package is responsible for verifying the buildah build task\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome dockerfile_param in _dockerfile_params\n\t_not_allowed_prefix(dockerfile_param)\n\tresult := lib.result_helper(rego.metadata.chain(), [dockerfile_param])\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Inaccessible parent image config\n\nThe parent image config is not accessible.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t_has_parent\n\tparent_ref := image.parse(_parent.ref)\n\tis_null(_config(parent_ref.repo, _parent.manifest))\n\tresult := lib.result_helper(rego.metadata.chain(), [_parent.ref, input.image.ref])\n}", "task_type": "implement"}
{"instruction": "Write a attestation_type rule: Known attestation type found\n\nConfirm the attestation found for the image has a known\nattestation type.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\n\t# regal ignore:leaked-internal-reference\n\tatt_type := att.statement._type\n\tnot att_type in lib.rule_data(_rule_data_key)\n\tresult := lib.result_helper(rego.metadata.chain(), [att_type])\n}", "task_type": "implement"}
{"instruction": "Write a quay_expiration rule: Expires label\n\nCheck the image metadata for the presence of a \"quay.expires-after\"\nlabel. If it's present then produce a violation. This check is enforced\nonly for a \"release\", \"production\", or \"staging\" pipeline, as determined by\nthe value of the `pipeline_intention` rule data.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package quay_expiration\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\t# This is where we can access the image labels\n\tsome label_name, label_value in input.image.config.Labels\n\n\t# The quay.expires-after label is present\n\tlabel_name == \"quay.expires-after\"\n\n\t# Send up the violation the details\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a sbom rule: Found\n\nConfirm an SBOM attestation exists.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom\nimport rego.v1\nimport data.lib\nimport data.lib.konflux\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# TODO: Workaround until Konflux produces SBOMs for Image Indexes:\n\t# https://issues.redhat.com/browse/KONFLUX-4330\n\tnot konflux.is_validating_image_index\n\n\tcount(_sboms) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_source_version_controlled rule: Materials include git commit shas\n\nEnsure that each entry in the predicate.materials array with a SHA-1 digest includes\na valid Git commit SHA.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_source_version_controlled\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome material in materials\n\tcommit := material.digest.sha1\n\tnot regex.match(`^[a-f0-9]{40}$`, commit)\n\tresult := lib.result_helper(rego.metadata.chain(), [commit])\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: OLM\n\nChecks for Operator Lifecycle Manager (OLM) bundles.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\tversion := object.get(manifest, [\"spec\", \"version\"], \"<MISSING>\")\n\tnot semver.is_valid(version)\n\tresult := lib.result_helper(rego.metadata.chain(), [version])\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Successful pipeline tasks\n\nEnsure that all of the Tasks in the Pipeline completed successfully. Note that\nskipped Tasks are not taken into account and do not influence the outcome.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\tsome status in _status(task)\n\tstatus != \"Succeeded\"\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), status], tekton.pipeline_task_name(task),\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a schedule rule: Rule data provided\n\nConfirm the expected rule data keys have been provided in the expected format. The keys are\n`disallowed_weekdays` and `disallowed_dates`.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\t# (For this one let's do it always)\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_cyclonedx rule: Allowed package sources\n\nFor each of the components fetched by Hermeto which define externalReferences of type\ndistribution, verify they are allowed based on the allowed_package_sources rule data\nkey. By default, allowed_package_sources is empty, which means no components with such\nreferences are allowed.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\n\t# only look at components that define an externalReferences of type `distribution`\n\tsome reference in component.externalReferences\n\treference.type == \"distribution\"\n\n\t# only look at components fetched by Hermeto\n\t# cachi2 is kept here for backwards compatibility\n\tsome properties in component.properties\n\tproperties.name in {\"hermeto:found_by\", \"cachi2:found_by\"}\n\tproperties.value in {\"hermeto\", \"cachi2\"}\n\n\tpurl := component.purl\n\tparsed_purl := ec.purl.parse(purl)\n\n\t# patterns are either those defined by the rule for a given purl type, or empty by default\n\tallowed_data := lib.rule_data(sbom.rule_data_allowed_package_sources_key)\n\tpatterns := sbom.purl_allowed_patterns(parsed_purl.type, allowed_data)\n\tdistribution_url := object.get(reference, \"url\", \"\")\n\n\t# only progress past this point if no matches were found\n\tnot sbom.url_matches_any_pattern(distribution_url, patterns)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [purl, distribution_url], purl)\n}", "task_type": "implement"}
{"instruction": "Write a git_branch rule: Git branch checks\n\nCheck that the build has an expected target git branch. The\nspecific branches permitted are specified as a list of regexes\nin the `allowed_target_branch_patterns` rule data.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package git_branch\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome task in lib.tasks_from_pipelinerun\n\n\t# Note that we're assuming that the annotation exists.\n\t# This will not produce a violation if the annotation is missing\n\tbranch := task.invocation.environment.annotations[\"build.appstudio.redhat.com/target_branch\"]\n\tnot matches_any(branch)\n\tresult := lib.result_helper(rego.metadata.chain(), [branch])\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Related images references are from allowed registries\n\nEach image indicated as a related image should match an entry in the list of prefixes\ndefined by the rule data key `allowed_olm_image_registry_prefixes` in your policy configuration.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\t# The presence of expected rule_data verified in _rule_data_errors\n\tallowed_olm_image_registry_prefixes := lib.rule_data(\"allowed_olm_image_registry_prefixes\")\n\n\t# Parse manifests from snapshot\n\tsome related_images in _related_images(input.image)\n\n\tsome img in related_images\n\tnot _image_registry_allowed(img.repo, allowed_olm_image_registry_prefixes)\n\n\timg_str := image.str(img)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [img_str], img.repo)\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Feature annotations have expected value\n\nCheck the feature annotations in the ClusterServiceVersion manifest of the OLM bundle. All of\nrequired feature annotations must be present and set to either the string `\"true\"` or the string\n`\"false\"`. The list of feature annotations can be customize via the\n`required_olm_features_annotations` rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\tsome annotation in lib.rule_data(\"required_olm_features_annotations\")\n\tvalue := object.get(manifest.metadata.annotations, annotation, \"\")\n\tnot value in {\"true\", \"false\"}\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [annotation], annotation)\n}", "task_type": "implement"}
{"instruction": "Write a provenance_materials rule: Git clone task found\n\nConfirm that the attestation contains a git-clone task with `commit` and `url` task results.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package provenance_materials\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tcount(tekton.git_clone_tasks(attestation)) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a github_certificate rule: Rule data provided\n\nConfirm the expected rule data keys have been provided in the expected format. The keys are\n`allowed_gh_workflow_repos`, `allowed_gh_workflow_refs`, `allowed_gh_workflow_names`,\nand `allowed_gh_workflow_triggers`.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_signature rule: Allowed RPM signature key\n\nThe SLSA Provenance attestation for the image is inspected to ensure RPMs have been signed by\npre-defined set of signing keys. The list of signing keys can be set via the\n`allowed_rpm_signature_keys` rule data. Use the special value \"unsigned\" to allow unsigned RPMs.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_signature\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome key in _signature_keys\n\tnot key in _allowed_rpm_signature_keys\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [key, _allowed_rpm_signature_keys], key)\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Unpinned images in OLM bundle\n\nCheck the OLM bundle image for the presence of unpinned image references.\nUnpinned image pull references are references to images found in\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\n\tsome i in all_image_ref(manifest)\n\ti.ref.digest == \"\" # unpinned image references have no digest\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image.str(i.ref), i.path], image.str(i.ref))\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Pipeline run includes at least one task\n\nEnsure that at least one Task is present in the PipelineRun\nattestation.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tcount(tekton.tasks(att)) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Unable to access related images for a component\n\nCheck the input image for the presence of related images.\nEnsure that all images are accessible.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tsome unmatched_image in _related_images_not_in_snapshot\n\tunmatched_ref := _image_ref(unmatched_image)\n\n\t# Add a check here to ensure unmatched_ref is not empty or malformed\n\tunmatched_ref != \"\"\n\n\tnot ec.oci.descriptor(unmatched_ref)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [unmatched_ref], unmatched_ref)\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Tasks\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_source_version_controlled rule: Materials have uri and digest\n\nConfirm at least one entry in the predicate.materials array of the attestation contains\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_source_version_controlled\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(lib.pipelinerun_attestations) > 0\n\tcount(materials) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Task references are tagged\n\nCheck if all Tekton Tasks defined with the bundle format contain a tag reference.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome task in tekton.untagged_task_references(lib.tasks_from_pipelinerun)\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), _task_info(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a buildah_build_task rule: disallowed_platform_patterns format\n\nConfirm the `disallowed_platform_patterns` rule data, if provided matches the expected format.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "implement"}
{"instruction": "Write a pre_build_script_task rule: Script runner image comes from allowed registry\n\nVerify that the images used to run the pre-build script tasks come from a known\nset of trusted registries to reduce potential supply chain attacks. By default this\npolicy defines trusted registries as registries that are fully maintained by Red\nHat and only contain content produced by Red Hat. The list of allowed registries\ncan be customized by setting the `allowed_registry_prefixes` list in the rule data.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\timage_ref := tekton.task_param(task, _pre_build_script_runner_image_param)\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "implement"}
{"instruction": "Write a base_image_registries rule: Base image comes from permitted registry\n\nVerify that the base images used when building a container image come from a known\nset of trusted registries to reduce potential supply chain attacks. By default this\npolicy defines trusted registries as registries that are fully maintained by Red\nHat and only contain content produced by Red Hat. The list of permitted registries\ncan be customized by setting the `allowed_registry_prefixes` list in the rule data.\nBase images that are found in the snapshot being validated are also allowed since EC\nwill also validate those images individually.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package base_image_registries\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome image_ref in _base_images\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "implement"}
{"instruction": "Write a rhtap_multi_ci rule: SLSA Provenance Attestation Found\n\nVerify an attestation created by the RHTAP Multi-CI build pipeline is present.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rhtap_multi_ci\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(_attestations) < 1\n\tresult := lib.result_helper(rego.metadata.chain(), [lib.quoted_values_string(_known_build_types)])\n}", "task_type": "implement"}
{"instruction": "Write a base_image_registries rule: Base image checks\n\nThis package is responsible for verifying the base (parent) images\nreported in the SLSA Provenace or the SBOM are allowed.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package base_image_registries\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome image_ref in _base_images\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "implement"}
{"instruction": "Write a attestation_type rule: PipelineRun attestation found\n\nConfirm at least one PipelineRun attestation is present.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(lib.pipelinerun_attestations) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a schedule rule: Weekday Restriction\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday := lower(time.weekday(lib.time.effective_current_time_ns))\n\tdisallowed := {lower(w) | some w in lib.rule_data(\"disallowed_weekdays\")}\n\tcount(disallowed) > 0\n\ttoday in disallowed\n\tresult := lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}", "task_type": "implement"}
{"instruction": "Write a rpm_packages rule: RPM Packages\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package rpm_packages\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\timage.is_image_index(input.image.ref)\n\n\tsome rpm_name in rpm_names_with_mismatched_nvr_sets\n\tnot rpm_name in lib.rule_data(\"non_unique_rpm_names\")\n\n\tdetail_text := concat(\" \", sort(rpm_mismatch_details(rpm_name)))\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[rpm_name, detail_text],\n\t\trpm_name,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a buildah_build_task rule: PRIVILEGED_NESTED parameter\n\nVerify the PRIVILEGED_NESTED parameter of a builder Tasks was not set to `true`.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome param in _privileged_nested_params\n\ttrim_space(param) == \"true\"\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a rhtap_multi_ci rule: SLSA Provenance Attestation Format\n\nConfirm the attestation created by the RHTAP Multi-CI build pipeline matches the\nexpected format.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n- j.validate_schema(data, schema)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rhtap_multi_ci\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n# j.validate_schema(data, schema): Validates data against JSON schema (alias for lib.json.validate_schema)\n", "output_code": "deny contains result if {\n\tsome att in _attestations\n\tsome ci_type in _known_ci_types\n\tatt.statement.predicate.buildDefinition.buildType == _build_type(ci_type)\n\tsome schema_error in j.validate_schema(att.statement.predicate, _predicate_schema(ci_type))\n\tresult := lib.result_helper(rego.metadata.chain(), [ci_type, schema_error.message])\n}", "task_type": "implement"}
{"instruction": "Write a buildah_build_task rule: Buildah task uses a local Dockerfile\n\nVerify the Dockerfile used in the buildah task was not\nfetched from an external source.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome dockerfile_param in _dockerfile_params\n\t_not_allowed_prefix(dockerfile_param)\n\tresult := lib.result_helper(rego.metadata.chain(), [dockerfile_param])\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Allowed package external references\n\nConfirm the SPDX SBOM contains only packages with explicitly allowed\nexternal references. By default all external references are allowed unless the\n\"allowed_external_references\" rule data key provides a list of type-pattern pairs\nthat forbid the use of any other external reference of the given type where the\nreference url matches the given pattern.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\tsome reference in pkg.externalRefs\n\tsome allowed in lib.rule_data(sbom.rule_data_allowed_external_references_key)\n\treference.referenceType == allowed.type\n\tnot regex.match(object.get(allowed, \"url\", \"\"), object.get(reference, \"referenceLocator\", \"\"))\n\n\tmsg := regex.replace(object.get(allowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\t# regal ignore:line-length\n\tresult := lib.result_helper(rego.metadata.chain(), [pkg.name, reference.referenceLocator, reference.referenceType, msg])\n}", "task_type": "implement"}
{"instruction": "Write a buildah_build_task rule: ADD_CAPABILITIES parameter\n\nVerify the ADD_CAPABILITIES parameter of a builder Tasks was not used.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome param in _add_capabilities_params\n\ttrim_space(param) != \"\"\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_source_correlated rule: Expected source code reference\n\nVerify that the provided source code reference is the one being attested.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tcount(_source_references) > 0\n\n\tsome expected_source in _expected_sources\n\n\t# TODO: this is rather loose, this checks that the expected source is\n\t# one of the attested sources, thus allowing also the inclusion of\n\t# unexpected source\n\tcount(expected_source.refs & _source_references) == 0\n\n\tsome attested_source in _source_references\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[sprintf(\"%s@%s\", [expected_source.expected_vcs_uri, expected_source.expected_revision])], attested_source,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a prefetch_dependencies rule: Prefetch dependencies mode parameter check\n\nVerify the prefetch-dependencies task in the PipelineRun attestation was not\ninvoked with the \"permissive\" mode parameter, which could compromise security.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package prefetch_dependencies\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(attestation)\n\tsome name in {\"prefetch-dependencies\", \"prefetch-dependencies-oci-ta\"}\n\tname in tekton.task_names(task)\n\ttekton.task_param(task, \"mode\") == \"permissive\"\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a cve rule: Non-blocking unpatched CVE check\n\nThe SLSA Provenance attestation for the image is inspected to ensure CVEs that do NOT have a\nknown fix and meet a certain security level have not been detected. If detected, this policy\nrule will raise a warning. By default, only CVEs of critical and high security level cause a\nwarning. This is configurable by the rule data key `warn_unpatched_cve_security_levels`. The\navailable levels are critical, high, medium, low, and unknown.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package cve\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome level, vulns in _grouped_vulns.warn_unpatched_cve_security_levels\n\tsome vuln in vulns\n\n\tname := _name(vuln)\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [name, level], name)\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Disallowed inherited labels\n\nCheck that certain labels on the image have different values than the labels\nfrom the parent image. If the label is inherited from the parent image but not\nredefined for the image, it will contain an incorrect value for the image.\nUse the rule data `disallowed_inherited_labels` key to set the list of labels\nto check, or the `fbc_disallowed_inherited_labels` key for fbc images.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome inherited_label in disallowed_inherited_labels\n\tname := inherited_label.name\n\t_value(_image_labels, name) == _value(_parent_labels, name)\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name], name),\n\t\tinherited_label,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a attestation_type rule: Deprecated policy attestation format\n\nThe Conforma CLI now places the attestation data in a different location.\nThis check fails if the expected new format is not found.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# Use input.attestations directly so we can detect the actual format in use.\n\tsome att in input.attestations\n\tnot att.statement\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Required OLM feature annotations list provided\n\nConfirm the `required_olm_features_annotations` rule data was provided, since it's\nrequired by the policy rules in this package.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a hermetic_task rule: Hermetic task\n\nThis package verifies that all the tasks in the attestation that\nare required to be hermetic were invoked with the proper\nparameters to perform a hermetic execution.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package hermetic_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome not_hermetic_task in _not_hermetic_tasks\n\tresult := lib.result_helper(rego.metadata.chain(), [tekton.task_name(not_hermetic_task)])\n}", "task_type": "implement"}
{"instruction": "Write a quay_expiration rule: Quay expiration\n\nPolicies to prevent releasing an image to quay that has a quay\nexpiration date. In Konflux images with an expiration date are\nproduced by \"on-pr\" build pipelines, i.e. pre-merge CI builds,\nso this is intended to prevent accidentally releasing a CI build.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package quay_expiration\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\t# This is where we can access the image labels\n\tsome label_name, label_value in input.image.config.Labels\n\n\t# The quay.expires-after label is present\n\tlabel_name == \"quay.expires-after\"\n\n\t# Send up the violation the details\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_build_scripted_build rule: Build task contains steps\n\nVerify that the predicate.buildConfig.tasks.steps attribute for the task\nresponsible for building and pushing the image is not empty.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_build_scripted_build\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tbuild_tasks := tekton.build_tasks(attestation)\n\tsome build_task in build_tasks\n\tcount(task_steps(build_task)) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [build_task.name])\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Trusted Task checks\n\nThis package is used to verify all the Tekton Tasks involved in building the image are trusted.\nTrust is established by comparing the Task references found in the SLSA Provenance with a\npre-defined list of trusted Tasks, which is expected to be provided as a data source that\ncreates the `data.trusted_tasks` in the format demonstrated at\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome task in tekton.untagged_task_references(lib.tasks_from_pipelinerun)\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), _task_info(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a slsa_provenance_available rule: Expected attestation predicate type found\n\nVerify that the predicateType field of the attestation indicates the in-toto SLSA Provenance\nformat was used to attest the PipelineRun.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_provenance_available\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tallowed_predicate_types := lib.rule_data(_rule_data_key)\n\tnot att.statement.predicateType in allowed_predicate_types\n\tresult := lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[att.statement.predicateType, concat(\", \", allowed_predicate_types)],\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Inaccessible image config\n\nThe image config is not accessible.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tmanifest := ec.oci.image_manifest(input.image.ref)\n\tdigest := object.get(manifest, [\"config\", \"digest\"], \"\")\n\tref := image.parse(input.image.ref)\n\tconfig := ec.oci.blob(sprintf(\"%s@%s\", [ref.repo, digest]))\n\tis_null(config)\n\tresult := lib.result_helper(rego.metadata.chain(), [input.image.ref])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_build_scripted_build rule: Build task set image digest and url task results\n\nConfirm that a build task exists and it has the expected\nIMAGE_DIGEST and IMAGE_URL task results.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_build_scripted_build\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tcount(tekton.build_tasks(attestation)) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a schedule rule: Date Restriction\n\nCheck if the current date is not allowed based on the rule data value\nfrom the key `disallowed_dates`. By default, the list is empty in which\ncase *any* day is allowed. This check is enforced only for a \"release\" or\n\"production\" pipeline, as determined by the value of the\n`pipeline_intention` rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday := time.format([lib.time.effective_current_time_ns, \"UTC\", \"2006-01-02\"])\n\tdisallowed := lib.rule_data(\"disallowed_dates\")\n\ttoday in disallowed\n\tresult := lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_source_correlated rule: Rule data provided\n\nConfirm the expected rule data keys have been provided in the expected format. The keys are\n`supported_vcs` and `supported_digests`.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_cyclonedx rule: Valid\n\nCheck the CycloneDX SBOM has the expected format. It verifies the CycloneDX SBOM matches the 1.5\nversion of the schema.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome index, s in sbom.cyclonedx_sboms\n\tsome violation in json.match_schema(s, schema_1_5)[1]\n\terror := violation.error\n\tresult := lib.result_helper(rego.metadata.chain(), [index, error])\n}", "task_type": "implement"}
{"instruction": "Write a sbom rule: Disallowed packages list is provided\n\nConfirm the `disallowed_packages` and `disallowed_attributes` rule data were\nprovided, since they are required by the policy rules in this package.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in lib.sbom.rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Trusted parameters\n\nConfirm certain parameters provided to each builder Task have come from trusted Tasks.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome build_task in tekton.build_tasks(attestation)\n\n\tsome param_name, param_value in tekton.task_params(build_task)\n\n\t# Trusted Artifacts are handled differently. Here we are concerned with all other parameters.\n\tnot endswith(param_name, \"_ARTIFACT\")\n\tparams_digests := _digests_from_values(lib.param_values(param_value))\n\n\tsome untrusted_digest in (params_digests - _trusted_build_digests)\n\tresult := lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[param_name, tekton.pipeline_task_name(build_task), untrusted_digest],\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a prefetch_dependencies rule: Prefetch Dependencies Task\n\nThis package verifies that the prefetch-dependencies task is invoked with\nappropriate parameters to ensure secure dependency fetching.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package prefetch_dependencies\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(attestation)\n\tsome name in {\"prefetch-dependencies\", \"prefetch-dependencies-oci-ta\"}\n\tname in tekton.task_names(task)\n\ttekton.task_param(task, \"mode\") == \"permissive\"\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a buildah_build_task rule: PLATFORM parameter\n\nVerify the value of the PLATFORM parameter of a builder Task is allowed by matching against a\nlist of disallowed patterns. The list of patterns can be customized via the\n`disallowed_platform_patterns` rule data key. If empty, all values are allowed.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome param in _platform_params\n\tsome pattern in lib.rule_data(_plat_patterns_rule_data_key)\n\tregex.match(pattern, param)\n\tresult := lib.result_helper(rego.metadata.chain(), [param, pattern])\n}", "task_type": "implement"}
{"instruction": "Write a pre_build_script_task rule: Script runner image is included in the sbom\n\nVerify that the image used to run the pre-build script task is\nincluded in the SBOM\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# This check does not apply to the image index for multi-arch builds\n\t# because its sbom is different to the sbom for the per-arch images\n\tnot image.is_image_index(input.image.ref)\n\tsome pre_build_image in _script_runner_image_refs\n\timage.parse(pre_build_image)\n\tnot _is_image_in_sbom(pre_build_image)\n\tresult := lib.result_helper(rego.metadata.chain(), [pre_build_image])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_build_scripted_build rule: Provenance subject matches build task image result\n\nVerify the subject of the attestations matches the IMAGE_DIGEST and\nIMAGE_URL values from the build task.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_build_scripted_build\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsubject_image_refs := collect_subjects(attestation)\n\n\tbuild_tasks := tekton.build_tasks(attestation)\n\n\tcount(build_tasks) > 0\n\n\t# all image results within all build tasks\n\tresult_image_refs := tekton.images_with_digests(build_tasks)\n\tsome subject_image_ref in subject_image_refs\n\tnot _contains_equal_ref(result_image_refs, subject_image_ref)\n\n\tresult := lib.result_helper(rego.metadata.chain(), [subject_image_ref])\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Subscription annotation has expected value\n\nCheck the value of the operators.openshift.io/valid-subscription annotation from the\nClusterServiceVersion manifest is in the expected format, i.e. JSON encoded non-empty array of\nstrings.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _subscriptions_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_repos rule: Known repo id list provided\n\nA list of known and permitted repository ids should be available in the rule data.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_repos\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [_rule_data_key, e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Valid\n\nCheck the SPDX SBOM has the expected format. It verifies the SPDX SBOM matches the 2.3\nversion of the schema.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome index, s in sbom.spdx_sboms\n\tsome violation in json.match_schema(s, schema_2_3)[1]\n\terror := violation.error\n\tresult := lib.result_helper(rego.metadata.chain(), [index, error])\n}", "task_type": "implement"}
{"instruction": "Write a sbom rule: SBOM\n\nChecks general properties of the SBOMs associated with the image being validated. More specific\nrules for SPDX and CycloneDX SBOMs are in separate packages.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom\nimport rego.v1\nimport data.lib\nimport data.lib.konflux\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# TODO: Workaround until Konflux produces SBOMs for Image Indexes:\n\t# https://issues.redhat.com/browse/KONFLUX-4330\n\tnot konflux.is_validating_image_index\n\n\tcount(_sboms) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Task version unsupported\n\nThe Tekton Task used is or will be unsupported. The Task is annotated with\n`build.appstudio.redhat.com/expires-on` annotation marking it as unsupported\nafter a certain date.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\n\tannotations := tekton.task_annotations(task)\n\n\texpires_on := annotations[_expires_on_annotation]\n\texpiry_message := object.get(\n\t\tannotations,\n\t\t_expiry_msg_annotation,\n\t\t\"Upgrade to a newer version of the Task.\",\n\t)\n\n\tresult := object.union(\n\t\tlib.result_helper_with_term(\n\t\t\trego.metadata.chain(),\n\t\t\t[tekton.task_name(task), tekton.pipeline_task_name(task), expires_on, expiry_message],\n\t\t\ttekton.task_name(task),\n\t\t),\n\t\t{\"effective_on\": expires_on},\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Disallowed package attributes\n\nConfirm the SPDX SBOM contains only packages without disallowed\nattributes. By default all attributes are allowed. Use the\n\"disallowed_attributes\" rule data key to provide a list of key-value pairs\nthat forbid the use of an attribute set to the given value.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\n\tsome externalref in pkg.externalRefs\n\n\tsome annotation in pkg.annotations\n\tproperties := json.unmarshal(annotation.comment)\n\tsome disallowed in lib.rule_data(sbom.rule_data_attributes_key)\n\tproperties.name == disallowed.name\n\n\tobject.get(properties, \"value\", \"\") == object.get(disallowed, \"value\", \"\")\n\n\tmsg := regex.replace(object.get(properties, \"value\", \"\"), `(.+)`, ` to \"$1\"`)\n\n\tid := object.get(externalref, \"referenceLocator\", pkg.name)\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [id, properties.name, msg], id),\n\t\tdisallowed,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: ClusterServiceVersion semver format\n\nCheck the `spec.version` value in the ClusterServiceVersion manifest of the OLM bundle uses a\nproperly formatted semver.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\tversion := object.get(manifest, [\"spec\", \"version\"], \"<MISSING>\")\n\tnot semver.is_valid(version)\n\tresult := lib.result_helper(rego.metadata.chain(), [version])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_source_correlated rule: Source code reference provided\n\nCheck if the expected source code reference is provided.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsource := object.get(input, [\"image\", \"source\"], {})\n\tcount(source) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: Test data found in task results\n\nEnsure that at least one of the tasks in the pipeline includes a\nTEST_OUTPUT task result, which is where Conforma expects\nto find test result data.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(lib.pipelinerun_attestations) > 0 # make sure we're looking at a PipelineRun attestation\n\tresults := lib.results_from_tests\n\tcount(results) == 0 # there are none at all\n\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a pre_build_script_task rule: Script runner image is listed in the task results\n\nVerify that the image used to run the pre-build script task is\nlisted in the task result SCRIPT_RUNNER_IMAGE_REFERENCE\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\tnot tekton.task_result(task, _pre_build_run_script_runner_image_result)\n\tresult := lib.result_helper(rego.metadata.chain(), [tekton.task_name(task)])\n}", "task_type": "implement"}
{"instruction": "Write a external_parameters rule: External parameters\n\nVerify the attribute .predicate.buildDefinition.externalParameters of a\nSLSA Provenance v1.0 matches the expectation.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package external_parameters\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome provenance in lib.pipelinerun_attestations\n\n\tparam_names := {p.name |\n\t\tsome p in provenance.statement.predicate.buildDefinition.externalParameters.runSpec.params\n\t\tp.value != \"\"\n\t}\n\texpected_names := {n | some n in lib.rule_data(_rule_data_key)}\n\n\texpected_names != param_names\n\tresult := lib.result_helper(rego.metadata.chain(), [param_names, expected_names])\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Data format\n\nConfirm the expected `trusted_tasks` data keys have been provided in the expected format.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in tekton.data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Data provided\n\nConfirm the expected data keys have been provided in the expected format. The keys are\n`pipeline-required-tasks` and `required-tasks`.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a rhtap_multi_ci rule: RHTAP Multi-CI\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package rhtap_multi_ci\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(_attestations) < 1\n\tresult := lib.result_helper(rego.metadata.chain(), [lib.quoted_values_string(_known_build_types)])\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Tasks using the latest versions\n\nCheck if all Tekton Tasks use the latest known Task reference. When warnings\nwill be reported can be configured using the `task_expiry_warning_days` rule\ndata setting. It holds the number of days before the task is to expire within\nwhich the warnings will be reported.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome task in lib.tasks_from_pipelinerun\n\texpiry := tekton.expiry_of(task)\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), time.format(expiry), _task_info(task), tekton.latest_trusted_ref(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a cve rule: Rule data provided\n\nConfirm the expected rule data keys have been provided in the expected format. The keys are\n`restrict_cve_security_levels`,\t`warn_cve_security_levels`,\n`restrict_unpatched_cve_security_levels`, and `warn_unpatched_cve_security_levels`.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package cve\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a test rule: Test data includes results key\n\nEach test result is expected to have a `results` key. Verify that the `results`\nkey is present in all of the TEST_OUTPUT task results.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\twith_results := [r.value.result | some r in lib.results_from_tests]\n\tcount(with_results) != count(lib.results_from_tests)\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a slsa_build_scripted_build rule: Image built by trusted Task\n\nVerify the digest of the image being validated is reported by a trusted Task in its IMAGE_DIGEST\nresult.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_build_scripted_build\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\texpected_ref := input.image.ref\n\texpected_digest := image.parse(expected_ref).digest\n\n\t# Find all the Tekton Bundle references from the Tasks that claim to have built the image being\n\t# validated.\n\ttasks := {build_task |\n\t\tsome attestation in lib.pipelinerun_attestations\n\t\tsome build_task in tekton.build_tasks(attestation)\n\t\tdigests := tekton.task_result_artifact_digest(build_task)\n\t\t_contains_digest(digests, expected_digest)\n\t}\n\n\terror := _trusted_build_task_error(tasks)\n\tresult := lib.result_helper(rego.metadata.chain(), [expected_ref, error])\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Matches image\n\nCheck the SPDX SBOM targets the image being validated.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsbom_image := image.parse(s.name)\n\texpected_image := image.parse(input.image.ref)\n\tsbom_image.digest != expected_image.digest\n\tresult := lib.result_helper(rego.metadata.chain(), [sbom_image.digest, expected_image.digest])\n}", "task_type": "implement"}
{"instruction": "Write a github_certificate rule: GitHub Workflow Name\n\nCheck if the value of the GitHub Workflow Name extension in the image\nsignature certificate matches one of the allowed values. Use the rule data\nkey `allowed_gh_workflow_names` to specify the list of allowed values.\nAn empty allow list, which is the default value, causes this check to succeeded.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a git_branch rule: Builds have a trusted target branch\n\nBuild must target a configured branch pattern (e.g., 'c10s')\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package git_branch\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome task in lib.tasks_from_pipelinerun\n\n\t# Note that we're assuming that the annotation exists.\n\t# This will not produce a violation if the annotation is missing\n\tbranch := task.invocation.environment.annotations[\"build.appstudio.redhat.com/target_branch\"]\n\tnot matches_any(branch)\n\tresult := lib.result_helper(rego.metadata.chain(), [branch])\n}", "task_type": "implement"}
{"instruction": "Write a source_image rule: Signed\n\nVerify the source container image is signed.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package source_image\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in _source_image_sig_errors\n\tresult := lib.result_helper(rego.metadata.chain(), [error])\n}", "task_type": "implement"}
{"instruction": "Write a rpm_ostree_task rule: rpm-ostree Task\n\nThis package is responsible for verifying the rpm-ostree Tekton Task was executed with the\nexpected parameters.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_ostree_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in builder_image_param_errors\n\tresult := _with_effective_on(lib.result_helper(rego.metadata.chain(), [error.msg]), error)\n}", "task_type": "implement"}
{"instruction": "Write a cve rule: Blocking unpatched CVE check\n\nThe SLSA Provenance attestation for the image is inspected to ensure CVEs that do NOT have a\nknown fix and meet a certain security level have not been detected. If detected, this policy\nrule will fail. By default, the list of security levels used by this policy is empty. This is\nconfigurable by the rule data key `restrict_unpatched_cve_security_levels`. The available levels\nare critical, high, medium, low, and unknown. In addition to that leeway can be granted per\nseverity using the `cve_leeway` rule data key containing days of allowed leeway, measured as\ntime between found vulnerability's public disclosure date and current effective time, per\nseverity level.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package cve\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome level, vulns in _grouped_vulns.restrict_unpatched_cve_security_levels\n\tsome vuln in vulns\n\n\tleeway := _compute_leeway(vuln, level)\n\tname := _name(vuln)\n\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, level], name),\n\t\tleeway,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a base_image_registries rule: Allowed base image registry prefixes list was provided\n\nConfirm the `allowed_registry_prefixes` rule data was provided, since it's\nrequired by the policy rules in this package.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package base_image_registries\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_cyclonedx rule: Allowed\n\nConfirm the CycloneDX SBOM contains only allowed packages. By default all packages are allowed.\nUse the \"disallowed_packages\" rule data key to provide a list of disallowed packages.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsbom.has_item(component.purl, lib.rule_data(sbom.rule_data_packages_key))\n\tresult := lib.result_helper(rego.metadata.chain(), [component.purl])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: No unsupported test result values found\n\nEnsure all test data result values are in the set of known/supported result values.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tall_unsupported := [u |\n\t\tsome result in lib.results_from_tests\n\t\ttest := result.value\n\t\tnot test.result in lib.rule_data(\"supported_tests_results\")\n\t\tu := {\"task\": result.name, \"result\": test.result}\n\t]\n\n\tcount(all_unsupported) > 0\n\tsome unsupported in all_unsupported\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[unsupported.task, unsupported.result],\n\t\tunsupported.task,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Trusted Artifact produced in pipeline\n\nAll input trusted artifacts must be produced on the pipeline. If they are not\nthe artifact could have been injected by a rogue task.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(attestation)\n\tsome invalid_input in _trusted_artifact_inputs(task)\n\tcount({o |\n\t\tsome t in tekton.tasks(attestation)\n\t\tsome o in _trusted_artifact_outputs(t)\n\n\t\to == invalid_input\n\t}) == 0\n\n\ttask_name = tekton.pipeline_task_name(task)\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[invalid_input, task_name],\n\t\tinvalid_input,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a github_certificate rule: GitHub Workflow Certificate Extensions\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult := lib.result_helper(rego.metadata.chain(), [extension.name])\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Required tasks list for pipeline was provided\n\nIMPORTANT: Only use existing helpers from the context. If a helper does not exist, write a TODO comment instead of creating a new helper function.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Deprecated labels\n\nCheck the image for the presence of labels that have been deprecated.\nUse the rule data key `deprecated_labels` to set the list of labels\nto check.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome label in _image_labels\n\tsome deprecated_label in lib.rule_data(\"deprecated_labels\")\n\tlabel.name == deprecated_label.name\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(\n\t\t\trego.metadata.chain(),\n\t\t\t[label.name, deprecated_label.replacement],\n\t\t\tlabel.name,\n\t\t),\n\t\tdeprecated_label,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: SPDX SBOM\n\nChecks different properties of the CycloneDX SBOMs associated with the image being validated.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome index, s in sbom.spdx_sboms\n\tsome violation in json.match_schema(s, schema_2_3)[1]\n\terror := violation.error\n\tresult := lib.result_helper(rego.metadata.chain(), [index, error])\n}", "task_type": "implement"}
{"instruction": "Write a github_certificate rule: GitHub Certificate Checks\n\nVerify attributes on the certificate involved in the image signature when using\nslsa-github-generator on GitHub Actions with Sigstore Fulcio\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult := lib.result_helper(rego.metadata.chain(), [extension.name])\n}", "task_type": "implement"}
{"instruction": "Write a sbom_cyclonedx rule: SBOM CycloneDX\n\nChecks different properties of the CycloneDX SBOMs associated with the image being validated.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome index, s in sbom.cyclonedx_sboms\n\tsome violation in json.match_schema(s, schema_1_5)[1]\n\terror := violation.error\n\tresult := lib.result_helper(rego.metadata.chain(), [index, error])\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Task tracking data was provided\n\nConfirm the `trusted_tasks` rule data was provided, since it's required by the policy rules in\nthis package.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\ttekton.missing_trusted_tasks_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a test rule: No tests produced warnings\n\nProduce a warning if any tests have their result set to \"WARNING\".\nThe result type is configurable by the \"warned_tests_results\" key in the rule data.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"warned_tests_results\"), \"warnings\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: OLM bundle images are not multi-arch\n\nOLM bundle images should be built for a single architecture. They should\nnot be OCI image indexes nor should they be Docker v2s2 manifest lists.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\t# Parse manifests from snapshot\n\tsome csv_manifest in _csv_manifests\n\n\t# If we have a CSV manifest, ensure that the input image is not an image index\n\timage.is_image_index(input.image.ref)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [input.image.ref], input.image.ref)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_repos rule: All rpms have known repo ids\n\nEach RPM package listed in an SBOM must specify the repository id that it comes from,\nand that repository id must be present in the list of known and permitted repository ids.\nCurrently this is rule enforced only for SBOM components created by cachi2.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_repos\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\t# Don't bother with this unless we have valid rule data\n\tcount(_rule_data_errors) == 0\n\n\tsome bad_purl, msg in _repo_id_errors\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [msg], bad_purl)\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Inaccessible image manifest\n\nThe image manifest is not accessible.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tmanifest := ec.oci.image_manifest(input.image.ref)\n\tis_null(manifest)\n\tresult := lib.result_helper(rego.metadata.chain(), [input.image.ref])\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: All required tasks are from trusted tasks\n\nEnsure that the all required tasks are resolved from trusted tasks.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\trequired_task_names := current_required_tasks.tasks # e.g. [[\"buildah\", \"buildah-remote\"], \"clair-scan\"]\n\n\t# flatten into a single array of strings\n\tflattened_required_tasks := flatten_list_to_sorted_array(required_task_names)\n\n\tsome att in lib.pipelinerun_attestations\n\tsome untrusted_task in tekton.untrusted_task_refs(lib.tasks_from_pipelinerun)\n\n\t# Check if any untrusted task matches a required task\n\tsome required_task_name in flattened_required_tasks\n\tsome untrusted_task_name in tekton.task_names(untrusted_task)\n\n\tuntrusted_task_name == required_task_name\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[_format_missing(untrusted_task_name, false)],\n\t\tuntrusted_task_name,\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a cve rule: CVE scan results found\n\nConfirm that clair-scan task results are present in the SLSA Provenance\nattestation of the build pipeline.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package cve\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tnot _clair_report.vulnerabilities\n\n\t# Index Images don't get a CVE scan report since it's just a reference to Image Manifests. The\n\t# report is only expected to be found on each of the individual Image Manifests.\n\tnot image.is_image_index(input.image.ref)\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Contains packages\n\nCheck the list of packages in the SPDX SBOM is not empty.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tcount(s.packages) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a external_parameters rule: Pipeline run params\n\nVerify the PipelineRun was initialized with a set of expected parameters.\nBy default it asserts git-repo, git-revision, and output-image are provided\nwith non-empty values. This is configurable by the rule data key\n`pipeline_run_params`. Any additional parameters are NOT allowed.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package external_parameters\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome provenance in lib.pipelinerun_attestations\n\n\tparam_names := {p.name |\n\t\tsome p in provenance.statement.predicate.buildDefinition.externalParameters.runSpec.params\n\t\tp.value != \"\"\n\t}\n\texpected_names := {n | some n in lib.rule_data(_rule_data_key)}\n\n\texpected_names != param_names\n\tresult := lib.result_helper(rego.metadata.chain(), [param_names, expected_names])\n}", "task_type": "implement"}
{"instruction": "Write a sbom_spdx rule: Allowed\n\nConfirm the SPDX SBOM contains only allowed packages. By default all packages are allowed.\nUse the \"disallowed_packages\" rule data key to provide a list of disallowed packages.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\tsome ref in pkg.externalRefs\n\tref.referenceType == \"purl\"\n\tsbom.has_item(ref.referenceLocator, lib.rule_data(sbom.rule_data_packages_key))\n\tresult := lib.result_helper(rego.metadata.chain(), [ref.referenceLocator])\n}", "task_type": "implement"}
{"instruction": "Write a github_certificate rule: GitHub Workflow Trigger\n\nCheck if the value of the GitHub Workflow Trigger extension in the image\nsignature certificate matches one of the allowed values. Use the rule data\nkey `allowed_gh_workflow_triggers` to specify the list of allowed values.\nAn empty allow list, which is the default value, causes this check to succeeded.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Unpinned images in input snapshot\n\nCheck the input snapshot for the presence of unpinned image references.\nUnpinned image pull references are references to images\nthat do not contain a digest -- uniquely identifying the version of\nthe image being pulled.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tinput_image = image.parse(input.image.ref)\n\tcomponents := input.snapshot.components\n\tsome component in components\n\tparsed_image := image.parse(component.containerImage)\n\tparsed_image.repo == input_image.repo\n\tparsed_image.digest == \"\" # unpinned image references have no digest\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image.str(parsed_image)], image.str(parsed_image))\n}", "task_type": "implement"}
{"instruction": "Write a attestation_type rule: Known attestation types provided\n\nConfirm the `known_attestation_types` rule data was provided.\n\nRequired helpers:\n- lib.result_helper_with_severity(chain, params, severity)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "implement"}
{"instruction": "Write a rpm_pipeline rule: Task version invalid_pipeline\n\nThe Tekton Task used specifies an invalid pipeline. The Task is annotated with\n`build.appstudio.redhat.com/pipeline` annotation, which must be in the set of\n`allowed_rpm_build_pipelines` in the rule data.\n\nRequired helpers:\n- lib.pipelinerun_attestations\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_pipeline\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\n\tlabels := tekton.task_labels(task)\n\tpipeline := labels[_pipeline_key]\n\tallowed_pipelines := lib.rule_data(_rule_data_key)\n\n\tnot pipeline in allowed_pipelines\n\n\tresult := lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), pipeline, concat(\",\", allowed_pipelines)],\n\t)\n}", "task_type": "implement"}
{"instruction": "Write a cve rule: Non-blocking CVE check\n\nThe SLSA Provenance attestation for the image is inspected to ensure CVEs that have a known fix\nand meet a certain security level have not been detected. If detected, this policy rule will\nraise a warning. By default, the list of CVE security levels used by this policy is empty.\nHowever, this is configurable by the rule data key `warn_cve_security_levels`. The available\nlevels are critical, high, medium, low, and unknown.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package cve\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome level, vulns in _grouped_vulns.warn_cve_security_levels\n\tsome vuln in vulns\n\n\tname := _name(vuln)\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [name, level], name)\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Unmapped images in OLM bundle\n\nCheck the OLM bundle image for the presence of unmapped image references.\nUnmapped image pull references are references to images found in\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tsnapshot_components := input.snapshot.components\n\tcomponent_images_digests := [component_image.digest |\n\t\tsome component in snapshot_components\n\t\tcomponent_image := image.parse(component.containerImage)\n\t]\n\n\tsome manifest in _csv_manifests\n\tall_image_refs := all_image_ref(manifest)\n\tunmatched_image_refs := [image |\n\t\tsome image in all_image_refs\n\t\tnot image.ref.digest in component_images_digests\n\t]\n\n\tsome unmatched_image in unmatched_image_refs\n\tnot ec.oci.image_manifest(image.str(unmatched_image.ref))\n\n\t# regal ignore:line-length\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image.str(unmatched_image.ref)], image.str(unmatched_image.ref))\n}", "task_type": "implement"}
{"instruction": "Write a rpm_ostree_task rule: Builder image parameter\n\nVerify the BUILDER_IMAGE parameter of the rpm-ostree Task uses an image reference that is both\npinned to a digest and starts with a pre-defined list of prefixes. By default, the list of\nprefixes is empty allowing any pinned image reference to be used. This is customizable via the\n`allowed_rpm_ostree_builder_image_prefixes` rule data.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package rpm_ostree_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in builder_image_param_errors\n\tresult := _with_effective_on(lib.result_helper(rego.metadata.chain(), [error.msg]), error)\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Images referenced by OLM bundle are from allowed registries\n\nEach image referenced by the OLM bundle should match an entry in the list of prefixes\ndefined by the rule data key `allowed_olm_image_registry_prefixes` in your policy configuration.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\t# The presence of expected rule_data verified in _rule_data_errors\n\tallowed_olm_image_registry_prefixes := lib.rule_data(\"allowed_olm_image_registry_prefixes\")\n\n\t# Parse manifests from snapshot\n\tsome csv_manifest in _csv_manifests\n\n\t# Parse image references from each manifest\n\tall_csv_images := all_image_ref(csv_manifest)\n\n\tsome img in all_csv_images\n\tnot _image_registry_allowed(img.ref.repo, allowed_olm_image_registry_prefixes)\n\n\timg_str := image.str(img.ref)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [img_str], img.ref.repo)\n}", "task_type": "implement"}
{"instruction": "Write a sbom_cyclonedx rule: Allowed package external references\n\nConfirm the CycloneDX SBOM contains only packages with explicitly allowed\nexternal references. By default all external references are allowed unless the\n\"allowed_external_references\" rule data key provides a list of type-pattern pairs\nthat forbid the use of any other external reference of the given type where the\nreference url matches the given pattern.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsome reference in component.externalReferences\n\tsome allowed in lib.rule_data(sbom.rule_data_allowed_external_references_key)\n\n\treference.type == allowed.type\n\tnot regex.match(object.get(allowed, \"url\", \"\"), object.get(reference, \"url\", \"\"))\n\n\tmsg := regex.replace(object.get(allowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\tid := object.get(component, \"purl\", component.name)\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [id, reference.url, reference.type, msg], id)\n}", "task_type": "implement"}
{"instruction": "Write a tasks rule: Required tasks list for pipeline was provided\n\nProduce a warning if the required tasks list rule data was not provided.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: OLM bundle image manifests contain only allowed resource kinds\n\nEvery manifest in an OLM bundle must be of an allowed resource kind,\nas defined by the rule data key `allowed_olm_resource_kinds`.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome path, manifest in input.image.files\n\n\t# Only consider files in the manifests directory (as defined by OLM label)\n\tmanifest_dir := input.image.config.Labels[manifestv1]\n\tstartswith(path, manifest_dir)\n\n\tnot manifest.kind in lib.rule_data(\"allowed_olm_resource_kinds\")\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [manifest.kind], manifest.kind)\n}", "task_type": "implement"}
{"instruction": "Write a trusted_task rule: Tasks are trusted\n\nCheck the trust of the Tekton Tasks used in the build Pipeline. There are two modes in which\ntrust is verified. The first mode is used if Trusted Artifacts are enabled. In this case, a\nchain of trust is established for all the Tasks involved in creating an artifact. If the chain\ncontains an untrusted Task, then a violation is emitted. The second mode is used as a fallback\nwhen Trusted Artifacts are not enabled. In this case, **all** Tasks in the build Pipeline must\nbe trusted.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome err in _trust_errors\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [err.msg], err.term)\n}", "task_type": "implement"}
{"instruction": "Write a slsa_source_version_controlled rule: Material uri is a git repo\n\nEnsure each entry in the predicate.materials array with a SHA-1 digest includes\na valid Git URI.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package slsa_source_version_controlled\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome material in materials\n\tnot startswith(material.uri, \"git+\")\n\tresult := lib.result_helper(rego.metadata.chain(), [material.uri])\n}", "task_type": "implement"}
{"instruction": "Write a github_certificate rule: GitHub Workflow Certificate Extensions\n\nCheck if the image signature certificate contains the expected GitHub\nextensions. These are the extensions that represent the GitHub workflow\ntrigger, sha, name, repository, and ref.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult := lib.result_helper(rego.metadata.chain(), [extension.name])\n}", "task_type": "implement"}
{"instruction": "Write a olm rule: Unpinned related images for a component\n\nCheck the input image for the presence of related images.\nEnsure all related image references include a digest.\n\nRequired helpers:\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package olm\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tunpinned_related_images := [related |\n\t\tsome related in _related_images_not_in_snapshot\n\n\t\t# If the image ref is not pinned this will be an empty string\n\t\trelated.digest == \"\"\n\t]\n\n\t# If any are unpinned we produce the violation\n\tcount(unpinned_related_images) > 0\n\n\tunpinned_refs := [_image_ref(r) | some r in unpinned_related_images]\n\n\tresult := lib.result_helper(rego.metadata.chain(), [count(unpinned_related_images), concat(\", \", unpinned_refs)])\n}", "task_type": "implement"}
{"instruction": "Write a schedule rule: Schedule related checks\n\nRules that verify the current date conform to a given schedule.\n\nRequired helpers:\n- lib.rule_data(key)\n- lib.result_helper(chain, params)\n\nThe rule should use 'deny contains result if' and return a result object using lib.result_helper.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday := lower(time.weekday(lib.time.effective_current_time_ns))\n\tdisallowed := {lower(w) | some w in lib.rule_data(\"disallowed_weekdays\")}\n\tcount(disallowed) > 0\n\ttoday in disallowed\n\tresult := lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}", "task_type": "implement"}
{"instruction": "Write a labels rule: Optional labels\n\nCheck the image for the presence of labels that are recommended,\nbut not required. Use the rule data `optional_labels` key to set\nthe list of labels to check, or the `fbc_optional_labels` key for\nfbc images.\n\nRequired helpers:\n- lib.result_helper_with_term(chain, params, term)\n\nThe rule should use 'warn contains result if' and return a result object using lib.result_helper.", "context": "package labels\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tfound_labels := {label.name | some label in _image_labels}\n\tsome optional_label in optional_labels\n\tname := optional_label.name\n\tnot name in found_labels\n\tdescription := optional_label.description\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, description], name),\n\t\toptional_label,\n\t)\n}", "task_type": "implement"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSLSA - Build - Build Service\n\nFix spacing, formatting, and style issues.", "context": "package slsa_build_build_service\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tnot _builder_id(att)\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tnot _builder_id(att)\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nImage digest is present in IMAGES_PROCESSED result\n\nFix spacing, formatting, and style issues.", "context": "package test\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\timg := image.parse(input.image.ref)\n\timg_digest := img.digest\n\n\tsome task in _grouped_processed_results_from_tests\n\n\tnot img_digest in object.get(task.value, [\"image\", \"digests\"], [])\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[task.name, img_digest],\n\t\ttask.name,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\timg:=image.parse(input.image.ref)\n\timg_digest:=img.digest\n\n\tsome task in _grouped_processed_results_from_tests\n\n\tnot img_digest in object.get(task.value, [\"image\", \"digests\"], [])\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[task.name, img_digest],\n\t\ttask.name,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRule data provided\n\nFix spacing, formatting, and style issues.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nBuilder image parameter\n\nFix spacing, formatting, and style issues.", "context": "package rpm_ostree_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in builder_image_param_errors\n\tresult := _with_effective_on(lib.result_helper(rego.metadata.chain(), [error.msg]), error)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in builder_image_param_errors\n\tresult:=_with_effective_on(lib.result_helper(rego.metadata.chain(), [error.msg]), error)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nScript runner image is a valid image reference\n\nFix spacing, formatting, and style issues.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\tref := tekton.task_result(task, _pre_build_run_script_runner_image_result)\n\tnot image.parse(ref)\n\tresult := lib.result_helper(rego.metadata.chain(), [ref])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\tref:=tekton.task_result(task, _pre_build_run_script_runner_image_result)\n\tnot image.parse(ref)\n\tresult:=lib.result_helper(rego.metadata.chain(), [ref])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nGitHub Certificate Checks\n\nFix spacing, formatting, and style issues.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult := lib.result_helper(rego.metadata.chain(), [extension.name])\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult:=lib.result_helper(rego.metadata.chain(), [extension.name])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nFound\n\nFix spacing, formatting, and style issues.", "context": "package sbom\nimport rego.v1\nimport data.lib\nimport data.lib.konflux\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# TODO: Workaround until Konflux produces SBOMs for Image Indexes:\n\t# https://issues.redhat.com/browse/KONFLUX-4330\n\tnot konflux.is_validating_image_index\n\n\tcount(_sboms) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# TODO: Workaround until Konflux produces SBOMs for Image Indexes:\n\t# https://issues.redhat.com/browse/KONFLUX-4330\n\tnot konflux.is_validating_image_index\n\n\tcount(_sboms)==0\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSource image\n\nFix spacing, formatting, and style issues.", "context": "package source_image\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in _source_image_errors\n\tresult := lib.result_helper(rego.metadata.chain(), [error])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in _source_image_errors\n\tresult:=lib.result_helper(rego.metadata.chain(), [error])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nValid\n\nFix spacing, formatting, and style issues.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome index, s in sbom.cyclonedx_sboms\n\tsome violation in json.match_schema(s, schema_1_5)[1]\n\terror := violation.error\n\tresult := lib.result_helper(rego.metadata.chain(), [index, error])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome index, s in sbom.cyclonedx_sboms\n\tsome violation in json.match_schema(s, schema_1_5)[1]\n\terror:=violation.error\n\tresult:=lib.result_helper(rego.metadata.chain(), [index, error])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nBuilds have a trusted target branch\n\nFix spacing, formatting, and style issues.", "context": "package git_branch\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome task in lib.tasks_from_pipelinerun\n\n\t# Note that we're assuming that the annotation exists.\n\t# This will not produce a violation if the annotation is missing\n\tbranch := task.invocation.environment.annotations[\"build.appstudio.redhat.com/target_branch\"]\n\tnot matches_any(branch)\n\tresult := lib.result_helper(rego.metadata.chain(), [branch])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome task in lib.tasks_from_pipelinerun\n\n\t# Note that we're assuming that the annotation exists.\n\t# This will not produce a violation if the annotation is missing\n\tbranch:=task.invocation.environment.annotations[\"build.appstudio.redhat.com/target_branch\"]\n\tnot matches_any(branch)\n\tresult:=lib.result_helper(rego.metadata.chain(), [branch])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTask version invalid_pipeline\n\nFix spacing, formatting, and style issues.", "context": "package rpm_pipeline\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\n\tlabels := tekton.task_labels(task)\n\tpipeline := labels[_pipeline_key]\n\tallowed_pipelines := lib.rule_data(_rule_data_key)\n\n\tnot pipeline in allowed_pipelines\n\n\tresult := lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), pipeline, concat(\",\", allowed_pipelines)],\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\n\tlabels:=tekton.task_labels(task)\n\tpipeline:=labels[_pipeline_key]\n\tallowed_pipelines:=lib.rule_data(_rule_data_key)\n\n\tnot pipeline in allowed_pipelines\n\n\tresult:=lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), pipeline, concat(\",\", allowed_pipelines)],\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nExternal parameters\n\nFix spacing, formatting, and style issues.", "context": "package external_parameters\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome provenance in lib.pipelinerun_attestations\n\n\tparam_names := {p.name |\n\t\tsome p in provenance.statement.predicate.buildDefinition.externalParameters.runSpec.params\n\t\tp.value != \"\"\n\t}\n\texpected_names := {n | some n in lib.rule_data(_rule_data_key)}\n\n\texpected_names != param_names\n\tresult := lib.result_helper(rego.metadata.chain(), [param_names, expected_names])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome provenance in lib.pipelinerun_attestations\n\n\tparam_names:={p.name |\n\t\tsome p in provenance.statement.predicate.buildDefinition.externalParameters.runSpec.params\n\t\tp.value != \"\"\n\t}\n\texpected_names:={n | some n in lib.rule_data(_rule_data_key)}\n\n\texpected_names != param_names\n\tresult:=lib.result_helper(rego.metadata.chain(), [param_names, expected_names])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nGitHub Workflow Trigger\n\nFix spacing, formatting, and style issues.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nOLM bundle image manifests contain only allowed resource kinds\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome path, manifest in input.image.files\n\n\t# Only consider files in the manifests directory (as defined by OLM label)\n\tmanifest_dir := input.image.config.Labels[manifestv1]\n\tstartswith(path, manifest_dir)\n\n\tnot manifest.kind in lib.rule_data(\"allowed_olm_resource_kinds\")\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [manifest.kind], manifest.kind)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome path, manifest in input.image.files\n\n\t# Only consider files in the manifests directory (as defined by OLM label)\n\tmanifest_dir:=input.image.config.Labels[manifestv1]\n\tstartswith(path, manifest_dir)\n\n\tnot manifest.kind in lib.rule_data(\"allowed_olm_resource_kinds\")\n\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [manifest.kind], manifest.kind)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nBase image comes from permitted registry\n\nFix spacing, formatting, and style issues.", "context": "package base_image_registries\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome image_ref in _base_images\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome image_ref in _base_images\n\tnot _image_ref_permitted(image_ref)\n\trepo:=image.parse(image_ref).repo\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nKnown attestation type found\n\nFix spacing, formatting, and style issues.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\n\t# regal ignore:leaked-internal-reference\n\tatt_type := att.statement._type\n\tnot att_type in lib.rule_data(_rule_data_key)\n\tresult := lib.result_helper(rego.metadata.chain(), [att_type])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\n\t# regal ignore:leaked-internal-reference\n\tatt_type:=att.statement._type\n\tnot att_type in lib.rule_data(_rule_data_key)\n\tresult:=lib.result_helper(rego.metadata.chain(), [att_type])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSLSA Builder ID found\n\nFix spacing, formatting, and style issues.", "context": "package slsa_build_build_service\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tnot _builder_id(att)\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tnot _builder_id(att)\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nBuildah task uses a local Dockerfile\n\nFix spacing, formatting, and style issues.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome dockerfile_param in _dockerfile_params\n\t_not_allowed_prefix(dockerfile_param)\n\tresult := lib.result_helper(rego.metadata.chain(), [dockerfile_param])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome dockerfile_param in _dockerfile_params\n\t_not_allowed_prefix(dockerfile_param)\n\tresult:=lib.result_helper(rego.metadata.chain(), [dockerfile_param])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nQuay expiration\n\nFix spacing, formatting, and style issues.", "context": "package quay_expiration\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\t# This is where we can access the image labels\n\tsome label_name, label_value in input.image.config.Labels\n\n\t# The quay.expires-after label is present\n\tlabel_name == \"quay.expires-after\"\n\n\t# Send up the violation the details\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\t# This is where we can access the image labels\n\tsome label_name, label_value in input.image.config.Labels\n\n\t# The quay.expires-after label is present\n\tlabel_name==\"quay.expires-after\"\n\n\t# Send up the violation the details\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nWeekday Restriction\n\nFix spacing, formatting, and style issues.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday := lower(time.weekday(lib.time.effective_current_time_ns))\n\tdisallowed := {lower(w) | some w in lib.rule_data(\"disallowed_weekdays\")}\n\tcount(disallowed) > 0\n\ttoday in disallowed\n\tresult := lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday:=lower(time.weekday(lib.time.effective_current_time_ns))\n\tdisallowed:={lower(w) | some w in lib.rule_data(\"disallowed_weekdays\")}\n\tcount(disallowed) > 0\n\ttoday in disallowed\n\tresult:=lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nrpm-ostree Task\n\nFix spacing, formatting, and style issues.", "context": "package rpm_ostree_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in builder_image_param_errors\n\tresult := _with_effective_on(lib.result_helper(rego.metadata.chain(), [error.msg]), error)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in builder_image_param_errors\n\tresult:=_with_effective_on(lib.result_helper(rego.metadata.chain(), [error.msg]), error)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nExpected source code reference\n\nFix spacing, formatting, and style issues.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tcount(_source_references) > 0\n\n\tsome expected_source in _expected_sources\n\n\t# TODO: this is rather loose, this checks that the expected source is\n\t# one of the attested sources, thus allowing also the inclusion of\n\t# unexpected source\n\tcount(expected_source.refs & _source_references) == 0\n\n\tsome attested_source in _source_references\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[sprintf(\"%s@%s\", [expected_source.expected_vcs_uri, expected_source.expected_revision])], attested_source,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tcount(_source_references) > 0\n\n\tsome expected_source in _expected_sources\n\n\t# TODO: this is rather loose, this checks that the expected source is\n\t# one of the attested sources, thus allowing also the inclusion of\n\t# unexpected source\n\tcount(expected_source.refs & _source_references)==0\n\n\tsome attested_source in _source_references\n\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[sprintf(\"%s@%s\", [expected_source.expected_vcs_uri, expected_source.expected_revision])], attested_source,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\ndisallowed_platform_patterns format\n\nFix spacing, formatting, and style issues.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nExpires label\n\nFix spacing, formatting, and style issues.", "context": "package quay_expiration\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\t# This is where we can access the image labels\n\tsome label_name, label_value in input.image.config.Labels\n\n\t# The quay.expires-after label is present\n\tlabel_name == \"quay.expires-after\"\n\n\t# Send up the violation the details\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\t# This is where we can access the image labels\n\tsome label_name, label_value in input.image.config.Labels\n\n\t# The quay.expires-after label is present\n\tlabel_name==\"quay.expires-after\"\n\n\t# Send up the violation the details\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nPre-build-script task checks\n\nFix spacing, formatting, and style issues.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\timage_ref := tekton.task_param(task, _pre_build_script_runner_image_param)\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\timage_ref:=tekton.task_param(task, _pre_build_script_runner_image_param)\n\tnot _image_ref_permitted(image_ref)\n\trepo:=image.parse(image_ref).repo\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSLSA Provenance Attestation Format\n\nFix spacing, formatting, and style issues.", "context": "package rhtap_multi_ci\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n# j.validate_schema(data, schema): Validates data against JSON schema (alias for lib.json.validate_schema)\n", "output_code": "deny contains result if {\n\tsome att in _attestations\n\tsome ci_type in _known_ci_types\n\tatt.statement.predicate.buildDefinition.buildType == _build_type(ci_type)\n\tsome schema_error in j.validate_schema(att.statement.predicate, _predicate_schema(ci_type))\n\tresult := lib.result_helper(rego.metadata.chain(), [ci_type, schema_error.message])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in _attestations\n\tsome ci_type in _known_ci_types\n\tatt.statement.predicate.buildDefinition.buildType==_build_type(ci_type)\n\tsome schema_error in j.validate_schema(att.statement.predicate, _predicate_schema(ci_type))\n\tresult:=lib.result_helper(rego.metadata.chain(), [ci_type, schema_error.message])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRule data provided\n\nFix spacing, formatting, and style issues.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\t# (For this one let's do it always)\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# (For this one let's do it always)\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nAllowed RPM signature key\n\nFix spacing, formatting, and style issues.", "context": "package rpm_signature\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome key in _signature_keys\n\tnot key in _allowed_rpm_signature_keys\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [key, _allowed_rpm_signature_keys], key)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome key in _signature_keys\n\tnot key in _allowed_rpm_signature_keys\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [key, _allowed_rpm_signature_keys], key)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nPinned Task references\n\nFix spacing, formatting, and style issues.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\tnot tekton.task_ref(task).pinned\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.task_name(task), tekton.pipeline_task_name(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\tnot tekton.task_ref(task).pinned\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.task_name(task), tekton.pipeline_task_name(task)],\n\t\ttekton.task_name(task),\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRPM Pipeline\n\nFix spacing, formatting, and style issues.", "context": "package rpm_pipeline\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\n\tlabels := tekton.task_labels(task)\n\tpipeline := labels[_pipeline_key]\n\tallowed_pipelines := lib.rule_data(_rule_data_key)\n\n\tnot pipeline in allowed_pipelines\n\n\tresult := lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), pipeline, concat(\",\", allowed_pipelines)],\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(att)\n\n\tlabels:=tekton.task_labels(task)\n\tpipeline:=labels[_pipeline_key]\n\tallowed_pipelines:=lib.rule_data(_rule_data_key)\n\n\tnot pipeline in allowed_pipelines\n\n\tresult:=lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), pipeline, concat(\",\", allowed_pipelines)],\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nClusterServiceVersion semver format\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\tversion := object.get(manifest, [\"spec\", \"version\"], \"<MISSING>\")\n\tnot semver.is_valid(version)\n\tresult := lib.result_helper(rego.metadata.chain(), [version])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome manifest in _csv_manifests\n\tversion:=object.get(manifest, [\"spec\", \"version\"], \"<MISSING>\")\n\tnot semver.is_valid(version)\n\tresult:=lib.result_helper(rego.metadata.chain(), [version])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRPM Packages\n\nFix spacing, formatting, and style issues.", "context": "package rpm_packages\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\timage.is_image_index(input.image.ref)\n\n\tsome rpm_name in rpm_names_with_mismatched_nvr_sets\n\tnot rpm_name in lib.rule_data(\"non_unique_rpm_names\")\n\n\tdetail_text := concat(\" \", sort(rpm_mismatch_details(rpm_name)))\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[rpm_name, detail_text],\n\t\trpm_name,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\timage.is_image_index(input.image.ref)\n\n\tsome rpm_name in rpm_names_with_mismatched_nvr_sets\n\tnot rpm_name in lib.rule_data(\"non_unique_rpm_names\")\n\n\tdetail_text:=concat(\" \", sort(rpm_mismatch_details(rpm_name)))\n\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[rpm_name, detail_text],\n\t\trpm_name,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nPrefetch dependencies mode parameter check\n\nFix spacing, formatting, and style issues.", "context": "package prefetch_dependencies\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(attestation)\n\tsome name in {\"prefetch-dependencies\", \"prefetch-dependencies-oci-ta\"}\n\tname in tekton.task_names(task)\n\ttekton.task_param(task, \"mode\") == \"permissive\"\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(attestation)\n\tsome name in {\"prefetch-dependencies\", \"prefetch-dependencies-oci-ta\"}\n\tname in tekton.task_names(task)\n\ttekton.task_param(task, \"mode\")==\"permissive\"\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nNo tests produced warnings\n\nFix spacing, formatting, and style issues.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"warned_tests_results\"), \"warnings\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"warned_tests_results\"), \"warnings\")\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nValid\n\nFix spacing, formatting, and style issues.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome index, s in sbom.spdx_sboms\n\tsome violation in json.match_schema(s, schema_2_3)[1]\n\terror := violation.error\n\tresult := lib.result_helper(rego.metadata.chain(), [index, error])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome index, s in sbom.spdx_sboms\n\tsome violation in json.match_schema(s, schema_2_3)[1]\n\terror:=violation.error\n\tresult:=lib.result_helper(rego.metadata.chain(), [index, error])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTask references are tagged\n\nFix spacing, formatting, and style issues.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome task in tekton.untagged_task_references(lib.tasks_from_pipelinerun)\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), _task_info(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome task in tekton.untagged_task_references(lib.tasks_from_pipelinerun)\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), _task_info(task)],\n\t\ttekton.task_name(task),\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSBOM\n\nFix spacing, formatting, and style issues.", "context": "package sbom\nimport rego.v1\nimport data.lib\nimport data.lib.konflux\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# TODO: Workaround until Konflux produces SBOMs for Image Indexes:\n\t# https://issues.redhat.com/browse/KONFLUX-4330\n\tnot konflux.is_validating_image_index\n\n\tcount(_sboms) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# TODO: Workaround until Konflux produces SBOMs for Image Indexes:\n\t# https://issues.redhat.com/browse/KONFLUX-4330\n\tnot konflux.is_validating_image_index\n\n\tcount(_sboms)==0\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nGitHub Workflow Certificate Extensions\n\nFix spacing, formatting, and style issues.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult := lib.result_helper(rego.metadata.chain(), [extension.name])\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome extension in [_TRIGGER, _SHA, _NAME, _REPOSITORY, _REF]\n\tnot _fulcio_extension_value(extension)\n\tresult:=lib.result_helper(rego.metadata.chain(), [extension.name])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nData format\n\nFix spacing, formatting, and style issues.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in tekton.data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in tekton.data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nScript runner image comes from allowed registry\n\nFix spacing, formatting, and style issues.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\timage_ref := tekton.task_param(task, _pre_build_script_runner_image_param)\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\timage_ref:=tekton.task_param(task, _pre_build_script_runner_image_param)\n\tnot _image_ref_permitted(image_ref)\n\trepo:=image.parse(image_ref).repo\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRule data provided\n\nFix spacing, formatting, and style issues.", "context": "package rpm_signature\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRPM Repos\n\nFix spacing, formatting, and style issues.", "context": "package rpm_repos\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [_rule_data_key, e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [_rule_data_key, e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRule data provided\n\nFix spacing, formatting, and style issues.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nBase images provided\n\nFix spacing, formatting, and style issues.", "context": "package base_image_registries\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t# Some images are built \"from scratch\" and not have any base images, e.g. UBI.\n\t# This check distinguishes such images by simply ensuring that at least one SBOM\n\t# is attached to the image.\n\tcount(sbom.all_sboms) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# Some images are built \"from scratch\" and not have any base images, e.g. UBI.\n\t# This check distinguishes such images by simply ensuring that at least one SBOM\n\t# is attached to the image.\n\tcount(sbom.all_sboms)==0\n\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nPipeline run includes at least one task\n\nFix spacing, formatting, and style issues.", "context": "package tasks\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tcount(tekton.tasks(att)) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tcount(tekton.tasks(att))==0\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRequired labels\n\nFix spacing, formatting, and style issues.", "context": "package labels\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tis_set(_image_labels)\n\n\tsome err in _required_labels_errors\n\tresult := object.union(lib.result_helper(rego.metadata.chain(), []), err)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tis_set(_image_labels)\n\n\tsome err in _required_labels_errors\n\tresult:=object.union(lib.result_helper(rego.metadata.chain(), []), err)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nNo tests were skipped\n\nFix spacing, formatting, and style issues.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"skipped_tests_results\"), \"n/a\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"skipped_tests_results\"), \"n/a\")\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nGit clone source matches materials provenance\n\nFix spacing, formatting, and style issues.", "context": "package provenance_materials\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\n\tsome task in tekton.git_clone_tasks(attestation)\n\turl := _normalize_git_url(tekton.task_result(task, \"url\"))\n\tcommit := tekton.task_result(task, \"commit\")\n\n\tmaterials := [m |\n\t\tsome m in attestation.statement.predicate.materials\n\t\tm.uri == url\n\t\tm.digest.sha1 == commit\n\t]\n\tcount(materials) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [url, commit])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\n\tsome task in tekton.git_clone_tasks(attestation)\n\turl:=_normalize_git_url(tekton.task_result(task, \"url\"))\n\tcommit:=tekton.task_result(task, \"commit\")\n\n\tmaterials:=[m |\n\t\tsome m in attestation.statement.predicate.materials\n\t\tm.uri==url\n\t\tm.digest.sha1==commit\n\t]\n\tcount(materials)==0\n\n\tresult:=lib.result_helper(rego.metadata.chain(), [url, commit])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nUnique Version\n\nFix spacing, formatting, and style issues.", "context": "package rpm_packages\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\timage.is_image_index(input.image.ref)\n\n\tsome rpm_name in rpm_names_with_mismatched_nvr_sets\n\tnot rpm_name in lib.rule_data(\"non_unique_rpm_names\")\n\n\tdetail_text := concat(\" \", sort(rpm_mismatch_details(rpm_name)))\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[rpm_name, detail_text],\n\t\trpm_name,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\timage.is_image_index(input.image.ref)\n\n\tsome rpm_name in rpm_names_with_mismatched_nvr_sets\n\tnot rpm_name in lib.rule_data(\"non_unique_rpm_names\")\n\n\tdetail_text:=concat(\" \", sort(rpm_mismatch_details(rpm_name)))\n\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[rpm_name, detail_text],\n\t\trpm_name,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTasks are trusted\n\nFix spacing, formatting, and style issues.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome err in _trust_errors\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [err.msg], err.term)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome err in _trust_errors\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [err.msg], err.term)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nUnpinned related images for a component\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tunpinned_related_images := [related |\n\t\tsome related in _related_images_not_in_snapshot\n\n\t\t# If the image ref is not pinned this will be an empty string\n\t\trelated.digest == \"\"\n\t]\n\n\t# If any are unpinned we produce the violation\n\tcount(unpinned_related_images) > 0\n\n\tunpinned_refs := [_image_ref(r) | some r in unpinned_related_images]\n\n\tresult := lib.result_helper(rego.metadata.chain(), [count(unpinned_related_images), concat(\", \", unpinned_refs)])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tunpinned_related_images:=[related |\n\t\tsome related in _related_images_not_in_snapshot\n\n\t\t# If the image ref is not pinned this will be an empty string\n\t\trelated.digest==\"\"\n\t]\n\n\t# If any are unpinned we produce the violation\n\tcount(unpinned_related_images) > 0\n\n\tunpinned_refs:=[_image_ref(r) | some r in unpinned_related_images]\n\n\tresult:=lib.result_helper(rego.metadata.chain(), [count(unpinned_related_images), concat(\", \", unpinned_refs)])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nDate Restriction\n\nFix spacing, formatting, and style issues.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday := time.format([lib.time.effective_current_time_ns, \"UTC\", \"2006-01-02\"])\n\tdisallowed := lib.rule_data(\"disallowed_dates\")\n\ttoday in disallowed\n\tresult := lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday:=time.format([lib.time.effective_current_time_ns, \"UTC\", \"2006-01-02\"])\n\tdisallowed:=lib.rule_data(\"disallowed_dates\")\n\ttoday in disallowed\n\tresult:=lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nNo informative tests failed\n\nFix spacing, formatting, and style issues.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\ttest in lib.rule_data(\"informative_tests\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\ttest in lib.rule_data(\"informative_tests\")\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nBase image checks\n\nFix spacing, formatting, and style issues.", "context": "package base_image_registries\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome image_ref in _base_images\n\tnot _image_ref_permitted(image_ref)\n\trepo := image.parse(image_ref).repo\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome image_ref in _base_images\n\tnot _image_ref_permitted(image_ref)\n\trepo:=image.parse(image_ref).repo\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [image_ref], repo)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nResult format\n\nFix spacing, formatting, and style issues.", "context": "package rpm_signature\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome error in _result_format_errors\n\tresult := lib.result_helper(rego.metadata.chain(), [error])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in _result_format_errors\n\tresult:=lib.result_helper(rego.metadata.chain(), [error])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRequired tasks list for pipeline was provided\n\nFix spacing, formatting, and style issues.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nDisallowed inherited labels\n\nFix spacing, formatting, and style issues.", "context": "package labels\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome inherited_label in disallowed_inherited_labels\n\tname := inherited_label.name\n\t_value(_image_labels, name) == _value(_parent_labels, name)\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name], name),\n\t\tinherited_label,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome inherited_label in disallowed_inherited_labels\n\tname:=inherited_label.name\n\t_value(_image_labels, name)==_value(_parent_labels, name)\n\tresult:=_with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name], name),\n\t\tinherited_label,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nExpected attestation predicate type found\n\nFix spacing, formatting, and style issues.", "context": "package slsa_provenance_available\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tallowed_predicate_types := lib.rule_data(_rule_data_key)\n\tnot att.statement.predicateType in allowed_predicate_types\n\tresult := lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[att.statement.predicateType, concat(\", \", allowed_predicate_types)],\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome att in lib.pipelinerun_attestations\n\tallowed_predicate_types:=lib.rule_data(_rule_data_key)\n\tnot att.statement.predicateType in allowed_predicate_types\n\tresult:=lib.result_helper(\n\t\trego.metadata.chain(),\n\t\t[att.statement.predicateType, concat(\", \", allowed_predicate_types)],\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTasks\n\nFix spacing, formatting, and style issues.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tnot required_pipeline_task_data\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nLabels\n\nFix spacing, formatting, and style issues.", "context": "package labels\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tfound_labels := {label.name | some label in _image_labels}\n\tsome optional_label in optional_labels\n\tname := optional_label.name\n\tnot name in found_labels\n\tdescription := optional_label.description\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, description], name),\n\t\toptional_label,\n\t)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tfound_labels:={label.name | some label in _image_labels}\n\tsome optional_label in optional_labels\n\tname:=optional_label.name\n\tnot name in found_labels\n\tdescription:=optional_label.description\n\tresult:=_with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [name, description], name),\n\t\toptional_label,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTrusted Task checks\n\nFix spacing, formatting, and style issues.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome task in tekton.untagged_task_references(lib.tasks_from_pipelinerun)\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), _task_info(task)],\n\t\ttekton.task_name(task),\n\t)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome task in tekton.untagged_task_references(lib.tasks_from_pipelinerun)\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[tekton.pipeline_task_name(task), _task_info(task)],\n\t\ttekton.task_name(task),\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nInaccessible parent image config\n\nFix spacing, formatting, and style issues.", "context": "package labels\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\t_has_parent\n\tparent_ref := image.parse(_parent.ref)\n\tis_null(_config(parent_ref.repo, _parent.manifest))\n\tresult := lib.result_helper(rego.metadata.chain(), [_parent.ref, input.image.ref])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t_has_parent\n\tparent_ref:=image.parse(_parent.ref)\n\tis_null(_config(parent_ref.repo, _parent.manifest))\n\tresult:=lib.result_helper(rego.metadata.chain(), [_parent.ref, input.image.ref])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nPipelineRun params provided\n\nFix spacing, formatting, and style issues.", "context": "package external_parameters\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nMatches image\n\nFix spacing, formatting, and style issues.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsbom_image := image.parse(s.name)\n\texpected_image := image.parse(input.image.ref)\n\tsbom_image.digest != expected_image.digest\n\tresult := lib.result_helper(rego.metadata.chain(), [sbom_image.digest, expected_image.digest])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsbom_image:=image.parse(s.name)\n\texpected_image:=image.parse(input.image.ref)\n\tsbom_image.digest != expected_image.digest\n\tresult:=lib.result_helper(rego.metadata.chain(), [sbom_image.digest, expected_image.digest])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nNo tests failed\n\nFix spacing, formatting, and style issues.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\tnot test in lib.rule_data(\"informative_tests\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\tnot test in lib.rule_data(\"informative_tests\")\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nAllowed builder IDs provided\n\nFix spacing, formatting, and style issues.", "context": "package slsa_build_build_service\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nUnpinned images in input snapshot\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tinput_image = image.parse(input.image.ref)\n\tcomponents := input.snapshot.components\n\tsome component in components\n\tparsed_image := image.parse(component.containerImage)\n\tparsed_image.repo == input_image.repo\n\tparsed_image.digest == \"\" # unpinned image references have no digest\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image.str(parsed_image)], image.str(parsed_image))\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tinput_image = image.parse(input.image.ref)\n\tcomponents:=input.snapshot.components\n\tsome component in components\n\tparsed_image:=image.parse(component.containerImage)\n\tparsed_image.repo==input_image.repo\n\tparsed_image.digest==\"\" # unpinned image references have no digest\n\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [image.str(parsed_image)], image.str(parsed_image))\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nDisallowed package attributes\n\nFix spacing, formatting, and style issues.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsome property in component.properties\n\tsome disallowed in lib.rule_data(sbom.rule_data_attributes_key)\n\n\tproperty.name == disallowed.name\n\tobject.get(property, \"value\", \"\") == object.get(disallowed, \"value\", \"\")\n\n\tmsg := regex.replace(object.get(property, \"value\", \"\"), `(.+)`, ` to \"$1\"`)\n\n\tid := object.get(component, \"purl\", component.name)\n\tresult := _with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [id, property.name, msg], id),\n\t\tdisallowed,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsome property in component.properties\n\tsome disallowed in lib.rule_data(sbom.rule_data_attributes_key)\n\n\tproperty.name==disallowed.name\n\tobject.get(property, \"value\", \"\")==object.get(disallowed, \"value\", \"\")\n\n\tmsg:=regex.replace(object.get(property, \"value\", \"\"), `(.+)`, ` to \"$1\"`)\n\n\tid:=object.get(component, \"purl\", component.name)\n\tresult:=_with_effective_on(\n\t\tlib.result_helper_with_term(rego.metadata.chain(), [id, property.name, msg], id),\n\t\tdisallowed,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSBOM CycloneDX\n\nFix spacing, formatting, and style issues.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome index, s in sbom.cyclonedx_sboms\n\tsome violation in json.match_schema(s, schema_1_5)[1]\n\terror := violation.error\n\tresult := lib.result_helper(rego.metadata.chain(), [index, error])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome index, s in sbom.cyclonedx_sboms\n\tsome violation in json.match_schema(s, schema_1_5)[1]\n\terror:=violation.error\n\tresult:=lib.result_helper(rego.metadata.chain(), [index, error])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nAll rpms have known repo ids\n\nFix spacing, formatting, and style issues.", "context": "package rpm_repos\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\t# Don't bother with this unless we have valid rule data\n\tcount(_rule_data_errors) == 0\n\n\tsome bad_purl, msg in _repo_id_errors\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [msg], bad_purl)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# Don't bother with this unless we have valid rule data\n\tcount(_rule_data_errors)==0\n\n\tsome bad_purl, msg in _repo_id_errors\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [msg], bad_purl)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nCVE scan results found\n\nFix spacing, formatting, and style issues.", "context": "package cve\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tnot _clair_report.vulnerabilities\n\n\t# Index Images don't get a CVE scan report since it's just a reference to Image Manifests. The\n\t# report is only expected to be found on each of the individual Image Manifests.\n\tnot image.is_image_index(input.image.ref)\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tnot _clair_report.vulnerabilities\n\n\t# Index Images don't get a CVE scan report since it's just a reference to Image Manifests. The\n\t# report is only expected to be found on each of the individual Image Manifests.\n\tnot image.is_image_index(input.image.ref)\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nUnmapped images in OLM bundle\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tsnapshot_components := input.snapshot.components\n\tcomponent_images_digests := [component_image.digest |\n\t\tsome component in snapshot_components\n\t\tcomponent_image := image.parse(component.containerImage)\n\t]\n\n\tsome manifest in _csv_manifests\n\tall_image_refs := all_image_ref(manifest)\n\tunmatched_image_refs := [image |\n\t\tsome image in all_image_refs\n\t\tnot image.ref.digest in component_images_digests\n\t]\n\n\tsome unmatched_image in unmatched_image_refs\n\tnot ec.oci.image_manifest(image.str(unmatched_image.ref))\n\n\t# regal ignore:line-length\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [image.str(unmatched_image.ref)], image.str(unmatched_image.ref))\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\n\tsnapshot_components:=input.snapshot.components\n\tcomponent_images_digests:=[component_image.digest |\n\t\tsome component in snapshot_components\n\t\tcomponent_image:=image.parse(component.containerImage)\n\t]\n\n\tsome manifest in _csv_manifests\n\tall_image_refs:=all_image_ref(manifest)\n\tunmatched_image_refs:=[image |\n\t\tsome image in all_image_refs\n\t\tnot image.ref.digest in component_images_digests\n\t]\n\n\tsome unmatched_image in unmatched_image_refs\n\tnot ec.oci.image_manifest(image.str(unmatched_image.ref))\n\n\t# regal ignore:line-length\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [image.str(unmatched_image.ref)], image.str(unmatched_image.ref))\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nKnown attestation types provided\n\nFix spacing, formatting, and style issues.", "context": "package attestation_type\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSchedule related checks\n\nFix spacing, formatting, and style issues.", "context": "package schedule\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday := lower(time.weekday(lib.time.effective_current_time_ns))\n\tdisallowed := {lower(w) | some w in lib.rule_data(\"disallowed_weekdays\")}\n\tcount(disallowed) > 0\n\ttoday in disallowed\n\tresult := lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tlib.pipeline_intention_match(rego.metadata.chain())\n\ttoday:=lower(time.weekday(lib.time.effective_current_time_ns))\n\tdisallowed:={lower(w) | some w in lib.rule_data(\"disallowed_weekdays\")}\n\tcount(disallowed) > 0\n\ttoday in disallowed\n\tresult:=lib.result_helper(rego.metadata.chain(), [today, concat(\", \", disallowed)])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSource code reference provided\n\nFix spacing, formatting, and style issues.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\nimport data.lib.json as j\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsource := object.get(input, [\"image\", \"source\"], {})\n\tcount(source) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsource:=object.get(input, [\"image\", \"source\"], {})\n\tcount(source)==0\n\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nDisallowed package external references\n\nFix spacing, formatting, and style issues.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\tsome reference in pkg.externalRefs\n\tsome disallowed in lib.rule_data(sbom.rule_data_disallowed_external_references_key)\n\n\treference.referenceType == disallowed.type\n\tregex.match(object.get(disallowed, \"url\", \"\"), object.get(reference, \"referenceLocator\", \"\"))\n\n\tmsg := regex.replace(object.get(disallowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\t# regal ignore:line-length\n\tresult := lib.result_helper(rego.metadata.chain(), [pkg.name, reference.referenceLocator, reference.referenceType, msg])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tsome pkg in s.packages\n\tsome reference in pkg.externalRefs\n\tsome disallowed in lib.rule_data(sbom.rule_data_disallowed_external_references_key)\n\n\treference.referenceType==disallowed.type\n\tregex.match(object.get(disallowed, \"url\", \"\"), object.get(reference, \"referenceLocator\", \"\"))\n\n\tmsg:=regex.replace(object.get(disallowed, \"url\", \"\"), `(.+)`, ` by pattern \"$1\"`)\n\n\t# regal ignore:line-length\n\tresult:=lib.result_helper(rego.metadata.chain(), [pkg.name, reference.referenceLocator, reference.referenceType, msg])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nImage built by trusted Task\n\nFix spacing, formatting, and style issues.", "context": "package slsa_build_scripted_build\nimport rego.v1\nimport data.lib\nimport data.lib.image\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\texpected_ref := input.image.ref\n\texpected_digest := image.parse(expected_ref).digest\n\n\t# Find all the Tekton Bundle references from the Tasks that claim to have built the image being\n\t# validated.\n\ttasks := {build_task |\n\t\tsome attestation in lib.pipelinerun_attestations\n\t\tsome build_task in tekton.build_tasks(attestation)\n\t\tdigests := tekton.task_result_artifact_digest(build_task)\n\t\t_contains_digest(digests, expected_digest)\n\t}\n\n\terror := _trusted_build_task_error(tasks)\n\tresult := lib.result_helper(rego.metadata.chain(), [expected_ref, error])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\texpected_ref:=input.image.ref\n\texpected_digest:=image.parse(expected_ref).digest\n\n\t# Find all the Tekton Bundle references from the Tasks that claim to have built the image being\n\t# validated.\n\ttasks:={build_task |\n\t\tsome attestation in lib.pipelinerun_attestations\n\t\tsome build_task in tekton.build_tasks(attestation)\n\t\tdigests:=tekton.task_result_artifact_digest(build_task)\n\t\t_contains_digest(digests, expected_digest)\n\t}\n\n\terror:=_trusted_build_task_error(tasks)\n\tresult:=lib.result_helper(rego.metadata.chain(), [expected_ref, error])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nContains packages\n\nFix spacing, formatting, and style issues.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tcount(s.packages) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tcount(s.packages)==0\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTest\n\nFix spacing, formatting, and style issues.", "context": "package test\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\ttest in lib.rule_data(\"informative_tests\")\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome test in _resulted_in(lib.rule_data(\"failed_tests_results\"), \"failures\")\n\ttest in lib.rule_data(\"informative_tests\")\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [test], test)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nADD_CAPABILITIES parameter\n\nFix spacing, formatting, and style issues.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome param in _add_capabilities_params\n\ttrim_space(param) != \"\"\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome param in _add_capabilities_params\n\ttrim_space(param) != \"\"\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRequired OLM feature annotations list provided\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nScript runner image is listed in the task results\n\nFix spacing, formatting, and style issues.", "context": "package pre_build_script_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\tnot tekton.task_result(task, _pre_build_run_script_runner_image_result)\n\tresult := lib.result_helper(rego.metadata.chain(), [tekton.task_name(task)])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.pre_build_tasks(attestation)\n\tnot tekton.task_result(task, _pre_build_run_script_runner_image_result)\n\tresult:=lib.result_helper(rego.metadata.chain(), [tekton.task_name(task)])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nDisallowed packages list is provided\n\nFix spacing, formatting, and style issues.", "context": "package sbom\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome error in lib.sbom.rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome error in lib.sbom.rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [error.message], error.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nImages referenced by OLM bundle are from allowed registries\n\nFix spacing, formatting, and style issues.", "context": "package olm\nimport rego.v1\nimport data.lib\nimport data.lib.image\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\t# The presence of expected rule_data verified in _rule_data_errors\n\tallowed_olm_image_registry_prefixes := lib.rule_data(\"allowed_olm_image_registry_prefixes\")\n\n\t# Parse manifests from snapshot\n\tsome csv_manifest in _csv_manifests\n\n\t# Parse image references from each manifest\n\tall_csv_images := all_image_ref(csv_manifest)\n\n\tsome img in all_csv_images\n\tnot _image_registry_allowed(img.ref.repo, allowed_olm_image_registry_prefixes)\n\n\timg_str := image.str(img.ref)\n\n\tresult := lib.result_helper_with_term(rego.metadata.chain(), [img_str], img.ref.repo)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\t# The presence of expected rule_data verified in _rule_data_errors\n\tallowed_olm_image_registry_prefixes:=lib.rule_data(\"allowed_olm_image_registry_prefixes\")\n\n\t# Parse manifests from snapshot\n\tsome csv_manifest in _csv_manifests\n\n\t# Parse image references from each manifest\n\tall_csv_images:=all_image_ref(csv_manifest)\n\n\tsome img in all_csv_images\n\tnot _image_registry_allowed(img.ref.repo, allowed_olm_image_registry_prefixes)\n\n\timg_str:=image.str(img.ref)\n\n\tresult:=lib.result_helper_with_term(rego.metadata.chain(), [img_str], img.ref.repo)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nAllowed\n\nFix spacing, formatting, and style issues.", "context": "package sbom_cyclonedx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsbom.has_item(component.purl, lib.rule_data(sbom.rule_data_packages_key))\n\tresult := lib.result_helper(rego.metadata.chain(), [component.purl])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome s in sbom.cyclonedx_sboms\n\tsome component in s.components\n\tsbom.has_item(component.purl, lib.rule_data(sbom.rule_data_packages_key))\n\tresult:=lib.result_helper(rego.metadata.chain(), [component.purl])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nSource reference\n\nFix spacing, formatting, and style issues.", "context": "package slsa_source_correlated\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tcount(_source_references) == 0\n\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tcount(_source_references)==0\n\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nTrusted Artifact produced in pipeline\n\nFix spacing, formatting, and style issues.", "context": "package trusted_task\nimport rego.v1\nimport data.lib\nimport data.lib.tekton\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(attestation)\n\tsome invalid_input in _trusted_artifact_inputs(task)\n\tcount({o |\n\t\tsome t in tekton.tasks(attestation)\n\t\tsome o in _trusted_artifact_outputs(t)\n\n\t\to == invalid_input\n\t}) == 0\n\n\ttask_name = tekton.pipeline_task_name(task)\n\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[invalid_input, task_name],\n\t\tinvalid_input,\n\t)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome attestation in lib.pipelinerun_attestations\n\tsome task in tekton.tasks(attestation)\n\tsome invalid_input in _trusted_artifact_inputs(task)\n\tcount({o |\n\t\tsome t in tekton.tasks(attestation)\n\t\tsome o in _trusted_artifact_outputs(t)\n\n\t\to==invalid_input\n\t})==0\n\n\ttask_name = tekton.pipeline_task_name(task)\n\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[invalid_input, task_name],\n\t\tinvalid_input,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nFuture required tasks were found\n\nFix spacing, formatting, and style issues.", "context": "package tasks\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_term(chain, params, term): Like result_helper but adds a 'term' field\n", "output_code": "warn contains result if {\n\tsome required_task in _missing_tasks(latest_required_tasks.tasks)\n\n\t# If the required_task is also part of the current_required_tasks, do\n\t# not proceed with a warning since that's clearly a violation.\n\tnot required_task in current_required_tasks.tasks\n\tresult := lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[_format_missing(required_task, true), latest_required_tasks.effective_on],\n\t\trequired_task,\n\t)\n}", "task_type": "refactor", "input_code": "warn contains result if {\n\tsome required_task in _missing_tasks(latest_required_tasks.tasks)\n\n\t# If the required_task is also part of the current_required_tasks, do\n\t# not proceed with a warning since that's clearly a violation.\n\tnot required_task in current_required_tasks.tasks\n\tresult:=lib.result_helper_with_term(\n\t\trego.metadata.chain(),\n\t\t[_format_missing(required_task, true), latest_required_tasks.effective_on],\n\t\trequired_task,\n\t)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nPLATFORM parameter\n\nFix spacing, formatting, and style issues.", "context": "package buildah_build_task\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.rule_data(key): Returns rule data value for the given key\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome param in _platform_params\n\tsome pattern in lib.rule_data(_plat_patterns_rule_data_key)\n\tregex.match(pattern, param)\n\tresult := lib.result_helper(rego.metadata.chain(), [param, pattern])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome param in _platform_params\n\tsome pattern in lib.rule_data(_plat_patterns_rule_data_key)\n\tregex.match(pattern, param)\n\tresult:=lib.result_helper(rego.metadata.chain(), [param, pattern])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nContains files\n\nFix spacing, formatting, and style issues.", "context": "package sbom_spdx\nimport rego.v1\nimport data.lib\nimport data.lib.sbom\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tcount(s.files) == 0\n\tresult := lib.result_helper(rego.metadata.chain(), [])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome s in sbom.spdx_sboms\n\tcount(s.files)==0\n\tresult:=lib.result_helper(rego.metadata.chain(), [])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRule data provided\n\nFix spacing, formatting, and style issues.", "context": "package github_certificate\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper_with_severity(chain, params, severity): Like result_helper but adds a 'severity' field\n", "output_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult := lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome e in _rule_data_errors\n\tresult:=lib.result_helper_with_severity(rego.metadata.chain(), [e.message], e.severity)\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nRestrict shared volumes\n\nFix spacing, formatting, and style issues.", "context": "package external_parameters\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.pipelinerun_attestations: List of PipelineRun attestations from input\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome provenance in lib.pipelinerun_attestations\n\tshared_workspaces := {w |\n\t\tsome w in provenance.statement.predicate.buildDefinition.externalParameters.runSpec.workspaces\n\t\tw.persistentVolumeClaim\n\t}\n\tcount(shared_workspaces) > 0\n\tresult := lib.result_helper(rego.metadata.chain(), [shared_workspaces])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome provenance in lib.pipelinerun_attestations\n\tshared_workspaces:={w |\n\t\tsome w in provenance.statement.predicate.buildDefinition.externalParameters.runSpec.workspaces\n\t\tw.persistentVolumeClaim\n\t}\n\tcount(shared_workspaces) > 0\n\tresult:=lib.result_helper(rego.metadata.chain(), [shared_workspaces])\n}"}
{"instruction": "Refactor the following rule to match correct Rego style:\n\nMaterial uri is a git repo\n\nFix spacing, formatting, and style issues.", "context": "package slsa_source_version_controlled\nimport rego.v1\nimport data.lib\n\n# Available helpers:\n# lib.result_helper(chain, params): Creates a result object with code, msg, and effective_on\n", "output_code": "deny contains result if {\n\tsome material in materials\n\tnot startswith(material.uri, \"git+\")\n\tresult := lib.result_helper(rego.metadata.chain(), [material.uri])\n}", "task_type": "refactor", "input_code": "deny contains result if {\n\tsome material in materials\n\tnot startswith(material.uri, \"git+\")\n\tresult:=lib.result_helper(rego.metadata.chain(), [material.uri])\n}"}
